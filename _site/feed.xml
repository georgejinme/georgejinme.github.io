<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GeorgeJin</title>
    <description>My personal webpage</description>
    <link>https://gougoumemeda.github.io/</link>
    <atom:link href="https://gougoumemeda.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 27 Dec 2016 18:23:36 +0800</pubDate>
    <lastBuildDate>Tue, 27 Dec 2016 18:23:36 +0800</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>Unity中使用Animation提高Animator的性能</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;序言&lt;/h2&gt;
&lt;p&gt;这次我要跟大家分享的是使用Animation来实现Animator的功能。其实效果没有之前Curve那么酷炫，但是工作量比之前的会大上好多。&lt;/p&gt;

&lt;p&gt;为什么要使用Animation来实现Animator呢？很大一部分原因是在于性能。Animator的性能是被人们所诟病的，在模拟之前我也不知道使用Animation能提高多少的性能，只是觉得可能是一种方式，所以就做了这件事。下面我们就进入正题，聊聊具体的方式。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;正文&lt;/h2&gt;
&lt;p&gt;平台：Unity 4.6&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;概念与运作方式&lt;/h3&gt;
&lt;p&gt;首先我们来明确一下Animator的概念以及运作方式。Animator本质上就是一个组件（Component），可以挂载到任意一个GameObject上，其核心在于AnimatorController。我们平常所看到的AnimatorController的图形化结构是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Animation/1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;本质上而言，AnimatorController就是多个状态机的组合，其中的状态就是动画，而状态的转换就是动画的过渡。我们要实现的呢，就是状态机。只不过里面还有很多细节和其他功能比如Layer，BlendTree等。&lt;/p&gt;

&lt;p&gt;我们从宏观到微观的角度来看controller，序号越小表示所包含的东西越多，概念越大：
1. controller本身，其中主要是paramaters和各个layer的基本信息。
2. layer，在animator中，我们对每一个layer都需要进行state和transition的更新。
3. stateMachine，通常来说，一个layer就是一个stateMachine，但是stateMachine也可以包含其他的sub-stateMachine。
4. state和transition，这些都是包含在stateMachine中的，也是controller中最核心的部分。
5. animationClip，包含在一个state中，真正动画播放的东西。&lt;/p&gt;

&lt;p&gt;下面我们一个一个具体的介绍上述部件的功能。&lt;/p&gt;

&lt;h4 id=&quot;parameters&quot;&gt;Parameters&lt;/h4&gt;
&lt;p&gt;“参数”是用来控制Transition的发生的。当参数满足一个Transition触发的所有条件时，这个Transition就会执行。从图形化的角度来看，参数就是以下图来表示的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Animation/2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们在代码中，可以通过SetInt，SetFloat等方法来修改参数的值。具体使用方法可以参考Unity手册。&lt;/p&gt;

&lt;h4 id=&quot;layer&quot;&gt;Layer&lt;/h4&gt;
&lt;p&gt;Layer在AnimatorController中，表示如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Animation/3.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;他的作用主要是用来控制不同层动画的混合，比如你有一个投掷的动画和一个走路的动画，你想上半身来投掷，下半身 走路的话，就可以通过Layer来实现。在Layer中我们看到有weight，Mask和Blending可以供开发者选择。weight用来控制混合 的权重，0表示不混合（动画不播放），其他数值会以一个融合的比重来播放动画，这里weight的值并不是绝对的，还会根据Blending的选择来更 改，如果Blending为Override，那么最终播放的时候当前层的动画会覆盖更浅层的动画，如果Blending为Additive，那么当前层 的weight会与更浅层的weight相加，再归一化。Mask是用来控制当前Layer的动画使用在身体的哪个部分的。我们可以在Unity中创建一 个Mask Avatar，通过设置它来达到控制身体部位的效果。&lt;/p&gt;

&lt;h4 id=&quot;statemachine&quot;&gt;StateMachine&lt;/h4&gt;

&lt;p&gt;一个StateMachine就是一个状态机，也就是我们最直观的看到的那一块区域：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Animation/4.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通常来说，一个layer就是一个stateMachine，但是stateMachine也可以包含其他的sub-stateMachine。&lt;/p&gt;

&lt;h4 id=&quot;state&quot;&gt;State&lt;/h4&gt;
&lt;p&gt;State在AnimatorController中表示为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Animation/5.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;实际上，一个State就包含了一个动画或者多个动画的融合（BlendTree）。在每一个State中，我们都可以找到AnimationClip，而它就是真正被播放的东西。我们状态机就是在不同的State之间进行转换，也就是在不同的动画中进行过渡与播放。值得一提的是，我们有一个很特殊的State叫AnyState，它可以表示任何一个State，换句话说，从它发出的Transition可以看作是从其他State中发出的。&lt;/p&gt;

&lt;h4 id=&quot;transition&quot;&gt;Transition&lt;/h4&gt;
&lt;p&gt;Transition就是在AnimatorController中的箭头，表示为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Animation/6.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当我们选中一个Transition时，可以在右边看到触发时的条件，这些条件必须全部都满足时才会被触发。Transition是一个动画到另一个动画的过渡，这个过渡是有时间的。当过渡完成之后，动画的状态才会切换。有一类Transition的条件仅仅是Exit Time，表示当动画播放了一段时间后自动会触发这个Transition。&lt;/p&gt;

&lt;p&gt;具体我们模拟Animator的时候，可以这么做（Update函数）：
1. 遍历每一个layer（可用多线程）
2. 在一个layer中，遍历当前state发出的所有transition，看看是否有所有conditions都满足的transition
3. 如果没有，结束
4. 如果有，则开始这个transition
5. transition是有时间的，所以当transition结束后，将当前的state设置成transition的dstState&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;实现&lt;/h3&gt;

&lt;h4 id=&quot;section-4&quot;&gt;解析&lt;/h4&gt;
&lt;p&gt;在实现这个Animator的时候，因为我们使用的是Unity 4.6，并没有与AnimatorController相关的API，所以我们需要自己解析controller文件。如果要看到controller文 件的原内容，我们需要设置一下Project Setting - Edtior，将其中的Aseet Serialization设置为Force Text，然后将controller文件使用任意编辑器打开（sublime），就能看到controller中所有的数据结构啦。我们在实际解析这些数据结构的时候，可以在代码中直接创建相应的类和成员变量，以State为例，在controller中他是这么表示的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gd&quot;&gt;--- !u!1102 &amp;amp;110273390
&lt;/span&gt;State:
  m_ObjectHideFlags: 3
  m_PrefabParentObject: {fileID: 0}
  m_PrefabInternal: {fileID: 0}
  m_Name: Attack01
  m_Speed: 1
  m_CycleOffset: 0
  m_Motions:
  - {fileID: 7400000, guid: 904f2f79e9c87534f903a673c7adb132, type: 3}
  m_ParentStateMachine: {fileID: 110728656}
  m_Position: {x: -94, y: 183, z: 0}
  m_IKOnFeet: 0
  m_Mirror: 0
  m_Tag: 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们创建的类如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class State
{
    public int m_id;
    public string m_Name;
    public float m_Speed;
    public float m_CycleOffset;
    public bool m_IKOnFeet;
    public bool m_Mirror;

    public List&amp;lt;AnimationClip&amp;gt; m_Motions; // one motion per motion set  
    public BlendTree m_MotionsWithBlendTree;

    public StateMachine m_ParentStateMachine;
    public Vector3 m_Position;
    public string m_Tag;

    public State(int id)
    {
        m_id = id;
        m_Motions = new List&amp;lt;AnimationClip&amp;gt;();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中，id为controller中第一行最后的那一串数字，其他的成员变量名字和controller中的大致都是一样的。因为一个 State可能是一个BlendTree，所以我们添加了一个m_MotionsWithBlendTree来表示这个State对应的 BlendTree（如果有的话）。然后，m_Motions存储的就是要被Animation播放的动画片段。&lt;/p&gt;

&lt;p&gt;这里有一点需要注意，我们需要将原来的动画片段复制一遍，把他的animationType设置成Lagecy，才能被Animation所支持。具体复制和设置的代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;string animationPath = &quot;Assets/Character/Animations/&quot; + guid + state.m_id + &quot;.FBX&quot;;
//AssetDatabase.CopyAsset(AssetDatabase.GUIDToAssetPath(guid), animationPath);
var animationObject = AssetDatabase.LoadAssetAtPath(animationPath, typeof(AnimationClip)) as AnimationClip;
if (!animationObject.name.Contains(state.m_id.ToString()))
      animationObject.name = animationObject.name + state.m_id;
AnimationUtility.SetAnimationType(animationObject, ModelImporterAnimationType.Legacy);
state.m_Motions.Add(animationObject);
state.m_MotionsWithBlendTree = null;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在上述代码中我们发现，我们对animationClip的名字进行的修改，原因在于，可能在不同Layer的两个State中有相同的AnimationClip，他们完全可以同时进行播放。在controller中，他们也是以不同的guid来表示的，说明他们是两个对象。而在Animation中，我们的Clip是以名字进行标识的，所以这里要给他们换一个名字。&lt;/p&gt;

&lt;p&gt;最后一点需要注意的是，还记不记得我们之前说在Layer中可以添加Mask。我们打开.mask文件后，发现会有一些m_Path，我们把m_Weight为1的所有path当成字符串保存起来，之后在模拟的时候会使用到。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;模拟&lt;/h4&gt;

&lt;p&gt;解析完controller文件后，就可以模拟Animator的行为了。&lt;/p&gt;

&lt;p&gt;首先我们要将所有的动画添加到Animation中去，在添加的时候，可以设置AnimationState.layer来实现不同layer的混合效果， 然后我们要实现mask的效果，可以使用函数AddMixingTransform，他接受两个参数，一个是transform，这里我们就可以使用解析 得到的m_Path了，使用transform.find(m_Path)就能得到我们真正需要的子transform（也就是mask），另一个参数表 示是否递归，这里根据.mask的文件结构来看，我们选择false即可。&lt;/p&gt;

&lt;p&gt;另外需要注意的是，Animation没有直观的数据结构可以表示BlendTree，我们要根据parameter的值以及各个动画片段的threshold来计算出他们的权重。这里以1D为例，计算权重的函数如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void UpdateWeightsAndSpeedsInBlendTree1D(AnimatorCompiler.BlendTree blendTree)
{
      float para = floatConditions[blendTree.m_BlendParameter.m_Name];
      AnimatorCompiler.BlendTree.Child left = null;
      AnimatorCompiler.BlendTree.Child right = null;
      for (int i = 0; i &amp;lt; blendTree.m_Childs.Count; ++i)
      {
            AnimatorCompiler.BlendTree.Child child = blendTree.m_Childs[i];
            if (para &amp;gt;= child.m_Threshold &amp;amp;&amp;amp; child.m_Threshold &amp;lt; blendTree.m_MaxThreshold)
            {
                  if (left == null || child.m_Threshold &amp;gt; left.m_Threshold)
                  {
                        left = child;
                  }
            }
            else if (para &amp;lt;= child.m_Threshold)
            {
                  if (right == null || child.m_Threshold &amp;lt; right.m_Threshold)
                  {
                        right = child;
                  }
            }
            weightInBlendTrees[blendTree][child] = 0.0f;
            speedInBlendTrees[blendTree][child] = 0.0f;
      }
      if (left != null &amp;amp;&amp;amp; right != null)
      {
            float lp = 1 - (para - left.m_Threshold) / (right.m_Threshold - left.m_Threshold);
            float rp = 1 - lp;
            weightInBlendTrees[blendTree][left] = lp;
            weightInBlendTrees[blendTree][right] = rp;
            float leftTime = left.m_Motion.length / left.m_TimeScale;
            float rightTime = right.m_Motion.length / right.m_TimeScale;
            speedInBlendTrees[blendTree][left] = left.m_Motion.length / (leftTime * lp + rightTime * rp);
            speedInBlendTrees[blendTree][right] = right.m_Motion.length / (leftTime * lp + rightTime * rp);
      }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;1D还是比较简单的，找到与parameter的值相邻的两个threshold，然后对这两个threshold所表示的AnimationClip的weight进行插值即可。2D的weight计算可以参考&lt;a href=&quot;http://runevision.com/thesis/rune_skovbo_johansen_thesis.pdf&quot;&gt;这篇文章&lt;/a&gt;的6.3节。&lt;/p&gt;

&lt;p&gt;大部分的更新Transition的逻辑都在Update函数中完成，那么我们要怎么来模拟这个Transition的过程呢？一种比较显然的方法是使用CrossFade，我们来看看CrossFade的函数原型。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void CrossFade(string animation, float fadeLength = 0.3F, PlayMode mode = PlayMode.StopSameLayer);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;animation为我们的目标动画，fadeLength就是过渡的时间，也就是transition的时间。我们解析得到的m_TransitionDuration是一个百分比，需要乘上原动画的时间。 CrossFade的原理是，将animation的weight设置成1，enable设置成true，然后在fadeLength的时间内将原动画的 weight降为0，再把他的enable设置成false。这样就有一个问题，在blendTree中的动画不一定weight就为1，而且在高层的 Layer中的weight也不一定为1，所以我们不能直接使用CrossFade，而是自己将它实现一遍再进行一些修改，大致的代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;foreach (var item in parser.animation.m_State)
{
      AnimatorCompiler.State state = item.Value;
      if (state.m_id == 0)
            continue;
      if (state.m_ParentStateMachine.m_Index == layer.m_Index)
      {
            if (state.m_id != transition.m_DstState.m_id)
            {
                  if (state.m_MotionsWithBlendTree == null)
                  {
                        gameObject.animation.Blend(state.m_Motions[0].name, 0, currentTransitionInLayers[layer].m_TransitionDuration * animationLength);
                  }
                  else
                  {
                        for (int j = 0; j &amp;lt; state.m_MotionsWithBlendTree.m_Childs.Count; ++j)
                        {
                              AnimatorCompiler.BlendTree.Child child = state.m_MotionsWithBlendTree.m_Childs[j];
                              gameObject.animation.Blend(child.m_Motion.name, 0, currentTransitionInLayers[layer].m_TransitionDuration * animationLength);
                        }
                  }
            }
      }
}
if (currentTransitionInLayers[layer].m_DstState.m_MotionsWithBlendTree == null)
{
      gameObject.animation.Stop(transition.m_DstState.m_Motions[0].name);
      gameObject.animation[transition.m_DstState.m_Motions[0].name].enabled = true;
      gameObject.animation[transition.m_DstState.m_Motions[0].name].weight = ((layer.m_Index == 0) ? 1 : layer.m_DefaultWeight);
}
else
{
      for (int i = 0; i &amp;lt; currentTransitionInLayers[layer].m_DstState.m_MotionsWithBlendTree.m_Childs.Count; ++i)
      {
            AnimatorCompiler.BlendTree.Child child = currentTransitionInLayers[layer].m_DstState.m_MotionsWithBlendTree.m_Childs[i];
            gameObject.animation.Stop(child.m_Motion.name);
            gameObject.animation[child.m_Motion.name].enabled = true;
            gameObject.animation[child.m_Motion.name].weight = weightInBlendTrees[currentTransitionInLayers[layer].m_DstState.m_MotionsWithBlendTree][child];
      }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;剩下的部分只要细心耐心的按照animator模拟的步骤慢慢实现即可，没有什么太多的坑。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;改进&lt;/h3&gt;

&lt;p&gt;好了，如果你按照上述的步骤写完了，然后想打包一下跃跃欲试，你会发现你失败了。原因是我们在复制AnimationClip的时候，使用了AssetDatabase，他是属于UnityEditor的一个类，而UnityEditor无法打包。因此我们需要把解析的过程放在Editor中完成，然后将解析的结果都串行化，保存起来。&lt;/p&gt;

&lt;p&gt;你可以小心翼翼的在每个类上面加上[System.Serializable]，但是这么做依然是不行的，因为我们在类中表示其他的对象时，使用都是其他对象的指针，所以很容易就产生循环引用，在Editor中无法被串行化，例如，state类中有一个parentStateMachine指向一个StateMachine，而在一个StateMachine中又保存了他所有state的指针。&lt;/p&gt;

&lt;p&gt;因此，我们需要修改整个解析得到的类的数据结构，将指针替换为对象的id（int类型）。以State为例，我们可以与之前的代码进行对比：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[System.Serializable]
public class State
{
      public int m_id;
      public string m_Name;
      public float m_Speed;
      public float m_CycleOffset;
      public bool m_IKOnFeet;
      public bool m_Mirror;

      public List&amp;lt;AnimationClip&amp;gt; m_Motions; // one motion per motion set    
      public int m_MotionsWithBlendTree;

      public int m_ParentStateMachine;
      public Vector3 m_Position;
      public string m_Tag;

      public State(int id)
      {
            m_id = id;
            m_Motions = new List&amp;lt;AnimationClip&amp;gt;();
            m_MotionsWithBlendTree = -1;
      }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由于我们把解析的过程放在了Editor中完成，因此运行的速度也会更快一些。&lt;/p&gt;

&lt;p&gt;那么我们还有什么办法可以提高性能吗？&lt;/p&gt;

&lt;p&gt;答案肯定是有的，这里就采用了“生成代码”的办法。我们真正运行时的逻辑代码，是在Editor中生成的，而不是提前写好的。可能听起来有点绕，我把我的工程的文件结构给大家看一下：&lt;/p&gt;

&lt;p&gt;Editor：
- AnimatorCodeGenerator.cs：生成模拟Animator的代码
- AnimatorParser：解析controller文件&lt;/p&gt;

&lt;p&gt;Scripts：
- AnimationByAnimator：模拟Animator
- AnimationController：控制gameObject
- AnimatorCompiler：controller文件的数据结构
- AnimatorData：用来存储解析controller文件后的结果
- CodeUtil：生成代码时使用的工具&lt;/p&gt;

&lt;p&gt;这样应该清晰了很多，那么这么做有什么好处呢？&lt;/p&gt;

&lt;p&gt;如果我们平常来写的话，必然会使用到大量的字典，比如parentStateMachineInStates，我们在解析的数据结构 中，parentStateMachine保存的是StateMachine的Id，只有id是没有办法直接在模拟代码中使用的，我们要把这个id换转成 真正的StateMachine的对象，因此他在模拟代码中的类型应该是Dictionary&amp;lt;State, StateMachine&amp;gt;。由于使用字典会产生大量的cache miss，因此性能并不出色。而生成代码最大的优势是能循环展开并且避免使用字典，其原理就在于能够“通过不同的字符串来运用变量”。&lt;/p&gt;

&lt;p&gt;我们来看一个例子，在codeGenerator中，有这样的一段代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (int i = 0; i &amp;lt; animation.m_Transition.Count; ++i)
{
      AnimatorCompiler.Transition transition = animation.m_Transition[i];
      code.Variable(&quot;&quot;, &quot;AnimatorCompiler.State&quot;, code.Normalize(&quot;srcStateInTransitions_&quot; + transition.m_id));
      code.Variable(&quot;&quot;, &quot;AnimatorCompiler.State&quot;, code.Normalize(&quot;dstStateInTransitions_&quot; + transition.m_id));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Variable函数就是创建响应的变量名。运行这段代码，生成的代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AnimatorCompiler.State srcStateInTransitions_110100396;
AnimatorCompiler.State dstStateInTransitions_110100396;
AnimatorCompiler.State srcStateInTransitions_110128666;
AnimatorCompiler.State dstStateInTransitions_110128666;
AnimatorCompiler.State srcStateInTransitions_110144588;
AnimatorCompiler.State dstStateInTransitions_110144588;
AnimatorCompiler.State srcStateInTransitions_110150974;
AnimatorCompiler.State dstStateInTransitions_110150974;
AnimatorCompiler.State srcStateInTransitions_110152432;
AnimatorCompiler.State dstStateInTransitions_110152432;
AnimatorCompiler.State srcStateInTransitions_110183908;
AnimatorCompiler.State dstStateInTransitions_110183908;
AnimatorCompiler.State srcStateInTransitions_110193682;
AnimatorCompiler.State dstStateInTransitions_110193682;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到，原先的Dictionary被展开成了不同的变量，而且我们把循环函数放在了Editor中完成，因此运行时的效率会更高一些。而这些就是生成代码所给我们带来的好处。&lt;/p&gt;

&lt;p&gt;不过，生成代码非常非常容易出错，大家在写的时候一定要仔细！&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;性能&lt;/h2&gt;

&lt;p&gt;测试时，我们重点关注Update函数消耗的时间，无论是Animator还是我们写的这个系统，Update函数始终都是核心，也是最最耗时的一部分。&lt;/p&gt;

&lt;p&gt;这次我们依然在安卓机上测试，创建300个物体，先挂上Animator，得到的图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Animation/7.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，所有Update函数的时间和为40.74+19.41=60.15ms。&lt;/p&gt;

&lt;p&gt;现在我们来看看用我们的系统：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Animation/8.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;总的Update函数时间为17.82+10.95+5.85=34.62ms。&lt;/p&gt;

&lt;p&gt;我们可以看到，在平均情况下，Animation实现的系统已经比Animator快了接近一倍，而在实现中可以优化的地方依旧有很多，代码也不是最美观，如果你有什么好的建议，欢迎联系我！&lt;/p&gt;

</description>
        <pubDate>Fri, 09 Sep 2016 21:00:00 +0800</pubDate>
        <link>https://gougoumemeda.github.io/2016/09/09/Unity%E4%B8%AD%E4%BD%BF%E7%94%A8Animation%E6%8F%90%E9%AB%98Animator%E7%9A%84%E6%80%A7%E8%83%BD/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2016/09/09/Unity%E4%B8%AD%E4%BD%BF%E7%94%A8Animation%E6%8F%90%E9%AB%98Animator%E7%9A%84%E6%80%A7%E8%83%BD/</guid>
        
        <category>Unity</category>
        
        <category>技术</category>
        
        <category>腾讯</category>
        
        
      </item>
    
      <item>
        <title>使用Shader实现任意曲线的颜色渐变和纹理移动</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;扯蛋时间&lt;/h2&gt;

&lt;p&gt;上次做了一个LineRender，手动Batch，对于我一个新手而言，这无疑是黑科技。&lt;/p&gt;

&lt;p&gt;但是我想错了。&lt;/p&gt;

&lt;p&gt;这次导师给我布置的任务才是真正的黑科技，我们需要在Material Inspector中绘制任意的曲线，来控制材质的颜色渐变和纹理的平移。我们都知道，shader中支持的类型都是非常基本的，float啊，int啊，稍微复杂一点的比如float4这样的，但是并没有一个类型能表示一条曲线。所以这次对我而言看上去是一个不小的挑战，但是既然来了腾讯，就要有面对挑战的决心和觉悟。当然，我也是完成了这项任务之后才来写这篇Blog的。我的导师非常善良，没有让我直接去画不规则曲线，而是先做了一个Sin函数变化曲线，然后通过设置参数的方式来调整一个他的图像，并且在Material Inspector中直观的显示出来。&lt;/p&gt;

&lt;p&gt;感兴趣的话，可以继续看下去。如果想直接看任意曲线部分，&lt;a href=&quot;#curve&quot;&gt;请猛戳我!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;sin&quot;&gt;Sin函数图像&lt;/h2&gt;

&lt;p&gt;我们先来看看结果是怎么样的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Curve/inspector.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;介绍一下各个参数吧：
- Time：动画的周期
- Speed：Sin函数在y轴上的拉伸
- OffsetY：Sin函数在y轴上的平移
- OffsetX：Sin函数在x轴上的平移
- 颜色选择框：Sin函数在两个极值时的颜色
- OffsetMax：纹理平移的最大位置
- OffsetMin：纹理平移的最小位置
- OffsetSpeedX：纹理在X轴平移的速度
- OffsetSpeedY：纹理在Y轴平移的速度&lt;/p&gt;

&lt;p&gt;我们可以看到，虽然说可以显示Sin函数的图像，但是其局限性还是相当大的。首先他本质上就是一个Sin函数，然后我们只是通过修改参数，看到Sin函数的变化，而不能在图像上直接增减Keyframe。但这个做法为我们之后任意曲线提供了思路。&lt;/p&gt;

&lt;p&gt;我们先定位到Shader文件中。在Shader中，我们实现了具体的算法，也就是说，给定上述提到的各个参数，怎么把颜色或者纹理的变化画出来。我们在绘制两种颜色之间的渐变时，使用的是插值的技术，也就是将两部分颜色按照一定的比例混合起来，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;o.color = v.color * (_TintColor * t + (1 - t) * _TintColorMin);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;两个变量的含义从名字就可以看出来。现在我们要思考如何把t算出来，这个t事实上就是Sin函数的y值。有过高中数学知识的朋友都知道，Sin函数的一般形式为&lt;code class=&quot;highlighter-rouge&quot;&gt;y=Asin(w(x + t)) + b&lt;/code&gt;。其中周期为2pi / w。我们将上述的参数都带入，得到：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;float t = saturate(sin((time + _SpeedColorOffsetX) / _Interval * 6.283185307) * _SpeedColorCutoff + _SpeedColorOffset);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样，我们就把颜色渐变的部分完成了，最外面的saturate函数是保证t的值始终在0-1之间，因为插值技术只支持t的范围为0-1。&lt;/p&gt;

&lt;p&gt;现在我们来看看纹理的平移要如何达到。其实纹理的平移更加简单，速度乘以时间就是平移的距离，但是要注意我们有一个最大最小值，要保证平移的距离在这个范围之内：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;currentUV += clamp(time * float2(_SpeedX, _SpeedY), _MinX, _MaxX);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;有一点需要提到，因为我们的动画是可以循环的，所以time的值为真实的时间对周期取模：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;float time = fmod(_Time.y, _Interval);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面就是Shader的主要思路，现在我们回到Editor，看看如何把这个Sin函数曲线画出来。其实非常简单，因为我们已经知道怎么算Sin函数了，所以我们只要在Editor中再算一边即可。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (float x = 0; x &amp;lt; interval; x = x + interval / 100)
{
	float value = Mathf.Sin((x + speedColorOffsetX) / interval * 6.283185307f) * speedColorCutoff + speedColorOffset;
	value = Mathf.Clamp(value, 0, 1);
	colorCurve.AddKey(new Keyframe(x, value));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们在Sin函数上取100个点进行采样，计算出这一百个点的值，然后把他封装成一个Keyframe，添加到AnimationCurve的Key中。注意一点，Keyframe是需要添加入切线和出切线的，但是我们并没有添加，所以在点少的情况下看上去并不像一个Sin函数，因此我们选择100个采样点，让两个点更加靠近，看上去就更像是一根平滑的曲线。至此，我们的Sin函数图像的绘制的就全部结束了，剩下的一下EditorGUILayout的调用查阅API手册即可。&lt;/p&gt;

&lt;p id=&quot;curve&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;任意曲线绘制&lt;/h2&gt;
&lt;p&gt;简单来说，我们接下去要做的事，就是能够直接在图像上增减Keyframe，不用手动输入参数，然后能够在Shader中计算出对应的值，通过插值的方法达到颜色渐变和纹理平移的效果。我们这里只说颜色渐变的方法，因为纹理平移和颜色渐变的思路是一模一样的，复制两次代码即可。&lt;/p&gt;

&lt;p&gt;老规矩，先看一张成品图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Curve/curveinspector.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里我们的参数就少了很多，唯一有的是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Loop：是否循环播放&lt;/li&gt;
  &lt;li&gt;Duration：周期&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们这次先来讲讲大致的思路是怎么样的。我遇到的第一个疑问是，对于任意一根曲线，怎么计算出在某一个x上的y的值？unity自带有一个方法叫做AnimationCurve.Evaluate(time)，我们传进去一个time，也就是x，就能帮我们计算出y的值。但是这个方法只能在C#中使用，如果要像Sin函数那样在Shader中计算一遍，那该怎么做呢？有同学可能会说，在C#中计算好再传进去，那样我们每一帧都要传递一个值，开销会很大，所以建议还是在Shader中做计算。事实上，我们只需要知道Evaluate函数具体的算法，在Shader中实现一遍就好了，于是我谷歌到了下面的东西：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;float evaluate(float time, float4 keyframe1, float4 keyframe0)
{
	float t = (time  - keyframe0.x) / (keyframe1.x - keyframe0.x);
	float dt = keyframe1.x - keyframe0.x;
	float m0 = keyframe0.w * dt;
	float m1 = keyframe1.z * dt;
	float t2 = t * t;
	float t3 = t2 * t;
	float a = 2 * t3 - 3 * t2 + 1;
	float b = t3 - 2 * t2 + t;
	float c = t3 - t2;
	float d = -2 * t3 + 3 * t2;
	float value = a * keyframe0.y + b * m0 + c * m1 + d * keyframe1.y;
	return saturate(value);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Nice！这就是Unity的Evaluate函数的具体实现。我们只要把这个函数搬到Shader的CGPROGRAM代码块中就好啦！&lt;/p&gt;

&lt;p&gt;但是新的问题又来了，这个函数需要两个keyframe参数（相邻的两个keyframe），这两个keyframe肯定是要从material editor中传进去的，如果我们只传这两个参数，那和用C#计算完把结果穿进去有什么区别呢，还是需要每一帧（可能多个帧）传递数据一次，毕竟时间在x轴上跑，相邻的两个keyframe会变。我们最理想的情况是，不会因为时间的缘故而传递数据。因此，我们需要在曲线绘制完毕后，就将所有的keyframe传进去，然后在Shader中计算此时相邻的keyframe是哪两个，这样开销会小很多。所以现在的关键点是，如何传递所有的keyframe到Shader中，以及如何计算出当前时间相邻的两个Keyframe？&lt;/p&gt;

&lt;p&gt;我们先来回答第一个问题。回到Editor，我们绘制曲线在OnInpectorGUI()这个函数中，有一点需要注意，我们必须将绘制完的曲线赋给原来的变量，否则曲线是不会变化的！&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;colorCurve = EditorGUILayout.CurveField(colorCurve, Color.green, new Rect(0, 0, 1.0f, 1.0f), GUILayout.Height(150));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后，&lt;code class=&quot;highlighter-rouge&quot;&gt;colorCurve&lt;/code&gt;就是我们最终得到的动画曲线。我们只要取colorCurve.keys就能够得到他所有的Keyframe了。这里有一点需要注意，我们在Editor中设置的曲线范围都是0-1之间的，而且keyFrame必须至少有2个，否则曲线就失去了意义，这点在代码中需要判断一下。另外，我们有一个Duration变量来控制周期，所以我们需要保证最后一个keyframe的x坐标必须为1，表示1秒，在最终绘制曲线的时候，会将时间放慢Duration倍，达到周期为Duration的效果，例如如果想在3.5秒完成一次动画，就把Duration设置成3.5即可。总而言之，Curve的绘制只是告诉我们变化的曲线，具体变化需要多久，由Duration来控制，这样做会使得美术更加容易理解，代码的实现也会更加简单。这部分代码在Shader中实现，Editor中只需要保证x的坐标为1即可：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (number &amp;gt;= 2)
{
	keys[number - 1].time = 1.0f;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后我们遍历每一个KeyFrame，传递到Shader中就好。&lt;/p&gt;

&lt;p&gt;现在回答第二个问题，如何知道离时间最近的两个Keyframe。最简单的方法就是在Shader中遍历所有的Keyframe，判断时间的关系。这么做可以，但是非常耗时，每一帧都需要遍历，而且每一个顶点都要遍历一遍。所以我没有采用这样的方法，而是做了一个Hash Table，在Editor中计算完之后传递给Shader，把变量命名为TimeTable，其中他的下标是时间（取整），值就是在下标表示的时间时下一个Keyframe的序号（Index）。这里需要插一句话，Keyframe在Shader中需要float4来存储，我们规定一根曲线上不能超过10个keyframe，所以三根曲线就有30个float4。而CG最多支持128个float4，因此我们大约只能再用90个float4。所以TimeTable的类型为float4，其中x，y，z分别为三根曲线所用。这里我们只介绍颜色，所以用x分量就可以。&lt;/p&gt;

&lt;p&gt;可能会有同学好奇，时间取整作为下标，那3.2秒和3.6秒时对应的Keyframe是同一个咯？如果在3.5秒和3.7秒有一个Keyframe的话，计算出的结果就是错误的！我们现在换个思路，TimeTable的大小为90，也就是说动画周期最长可以是90，但实际上我们根本不需要这么久的时间，动画周期在Editor里就已经确定了，而Editor中Keyframe的time最大就是1.0，所以我们可以将时间“拉长”90倍，也就是说，在每一个Keyframe的time上乘以90作为一个界限。这么说有点抽象，我们举个例子：假设在0.5秒和0.6秒有两个keyframe，如果直接取整，那么0.6秒这个keyframe会直接被无视掉。现在我们乘以90，得到45和54，也就是说，当真正的时间乘上90小于45的话，会取前面的keyframe，在45-54之间的话，就会取后面的keyframe，这样就把两个keyframe“区分”开来了，更直观一点，就是把他们的距离拉长了90倍，时间可以放进去了！&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (; currentTime &amp;lt;= (int)(keys[i + 1].time * 90); ++currentTime)
{
	timeTable[currentTime][type] = i + 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;代码就是这样，type就是x，y，z分量，最终我们在Shader中使用时，只要把真实的时间乘以90作为下标，就能得到正确的下一个keyframe了！&lt;/p&gt;

&lt;p&gt;现在我们两个问题都解决了！去Shader中看看具体剩下的部分吧！&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;float beginTime = _Time.y - v.time.x;
beginTime = max(0, beginTime);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这一部分是控制一个GameObject什么时候开始动画，如果没有这一块，那所有的GameObject都是同步动画的，因为他们共享的是同一个Material（为了Batch）。我们需要区分他们动画开始的时间，就需要在Mesh中把开始时间传递进去，如果没到那个时间，那当前动画运行的时间就始终是0，如果到了，那就是真实的动画运行时间了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;float time = ((1 - _Loop) * clamp(beginTime, 0, _Duration) + _Loop * fmod(beginTime, _Duration)) / _Duration;
float4 currentVector = _TimeTable[floor(time * 90)];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;time控制是否需要循环播放动画，而且范围始终在0-1之间，与Editor相匹配。由于我们除以了一个Duration，所以时间被放慢了Duration倍！达到了Duration控制周期的效果！后面一行的time*90就是之前所说过的部分。&lt;/p&gt;

&lt;p&gt;剩下的部分，就是找到keyframe，传到evaluate函数计算出结果，与颜色做插值，这些在Sin函数部分都已经讲过了，就不再重复了。&lt;/p&gt;

&lt;p&gt;到此为止，我们的代码就彻底完成啦！&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;性能测试&lt;/h2&gt;

&lt;p&gt;又到了喜闻乐见的性能测试环节了，先来看看用Animation做颜色渐变和纹理平移的效果。创建500个GameObject，挂载Animation，运行在安卓手机上：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Curve/animation.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关注Camera.Render，时间大约为38ms。现在来看看我们自己写的Shader执行颜色渐变和纹理平移的效率：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Curve/shader.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;发现Camera.Render的时间只要15ms左右。虽然没有Line Renderer那么惊艳，但是还是节约了一半多的时间，原因还是在Batch上面，因为我们是在Material和Shader中做这些事情，而同一个Material是自动会被Batch的，所以节约了一部分Draw Call的开销。此外，用Animation做还特别麻烦，需要每一种渐变效果都做一个Animation。而用Material，只要拖拖曲线，画画keyframe就好，美术会更加喜欢的！&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;当然，如果你有什么问题的话，请在评论中告诉我~&lt;/p&gt;
</description>
        <pubDate>Fri, 05 Aug 2016 00:00:00 +0800</pubDate>
        <link>https://gougoumemeda.github.io/2016/08/05/%E4%BD%BF%E7%94%A8Shader%E5%AE%9E%E7%8E%B0%E4%BB%BB%E6%84%8F%E6%9B%B2%E7%BA%BF%E7%9A%84%E9%A2%9C%E8%89%B2%E6%B8%90%E5%8F%98%E5%92%8C%E7%BA%B9%E7%90%86%E7%A7%BB%E5%8A%A8/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2016/08/05/%E4%BD%BF%E7%94%A8Shader%E5%AE%9E%E7%8E%B0%E4%BB%BB%E6%84%8F%E6%9B%B2%E7%BA%BF%E7%9A%84%E9%A2%9C%E8%89%B2%E6%B8%90%E5%8F%98%E5%92%8C%E7%BA%B9%E7%90%86%E7%A7%BB%E5%8A%A8/</guid>
        
        <category>Unity</category>
        
        <category>技术</category>
        
        <category>腾讯</category>
        
        
      </item>
    
      <item>
        <title>Unity中LineRender的实现与优化</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;闲聊&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.unity3d.com/Manual/class-LineRenderer.html&quot;&gt;Line Renderer&lt;/a&gt;，简单来说就是在一个三维的空间中生成一条线。既然是线，那么我们无论从那个角度上去看，都能看到他的正面对吧，毕竟线是在二位平面中的事物。那么在三维平面中，这个line是怎么做到的呢？其实很简单，我们镜头在旋转的过程中，保持line的正面始终面对着镜头就可以了。可能有人会说为什么不用一个圆柱体来搞定。原因很简单，圆柱体太重量级了，想象我们是在玩一个FPS游戏，我们不可能对每一个弹道都用一个圆柱体来表示吧，使用line renderer不仅仅可以实现一样的效果，而且开销更加小。&lt;/p&gt;

&lt;p&gt;Line Renderer和Billboard还有一些不一样，billboard对着你的角度也是固定死的，也就是说，无论镜头怎么变，billboard在你眼前的模样始终是一样的，这被广泛应用在NPC头上的字中。而line，只要给我们看到正面就可以了。&lt;/p&gt;

&lt;p&gt;给一张line的图片好了~&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/LineRenderer/line-render.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;我们究竟要干什么呢&lt;/h2&gt;

&lt;p&gt;用过Unity的朋友都知道，Unity自带了一种Line Renderer，在Effect Component中可以找到。这个line可以调整的参数是，起点的位置，终点的位置，起点的宽度以及终点的宽度，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/LineRenderer/para.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我想测试一下这个renderer的性能，于是我放了500个对象上去，发现他竟然用了500个draw call来一个一个画。嗯，是时候给Line Renderer瘦瘦身了！接下来我们就来自己实现这样一个line renderer，并且让他的性能比原生的更好。CPU的能耗很大一部分都在draw call上面，把这部分draw call给合并成一个，那么能耗会大大下降，而合并的方法，就是batch。Unity提供了静态Batch和动态Batch，当然也可以用代码手动创建Batch。除此之外，我们不能为一个GameObject创建Mesh Renderer，因为我们需要手动去batch，所以batch后的mesh也需要我们手动去绘制。&lt;/p&gt;

&lt;p&gt;所以，整体的步骤如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;写一个脚本，脚本创建Mesh，设置vertice和index。&lt;/li&gt;
  &lt;li&gt;在移动镜头的时候调整物体的位置，达到line的效果。&lt;/li&gt;
  &lt;li&gt;创建一个MeshCombine的脚本，其中包含一个BatchList，类型是List&lt;BatchInfo&gt;，能够把line都添加进去。Line会根据他们的Material和Layer自动归类到相应的BatchInfo，而一个BatchInfo只需要一次DrawCall。&lt;/BatchInfo&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接下来我们就一步一步的来实现这个功能。&lt;/p&gt;

&lt;h4 id=&quot;mesh&quot;&gt;脚本创建Mesh&lt;/h4&gt;
&lt;p&gt;这个其实比较简单，可以参考&lt;a href=&quot;http://www.cnblogs.com/kyokuhuang/p/4191169.html&quot;&gt;这篇文章&lt;/a&gt;。需要注意的是，文章中创建的是一个立方体，而我们只需要创建一个正方形。&lt;/p&gt;

&lt;p&gt;这里还有一点是可以优化的，刚才我们说，line只会把正面给镜头看，也就是说在游戏运行时，玩家是看不到物体的背面的，所以我们也不需要为背面划分三角形创建Index。综上所述，我们只要创建一个单一面的正方形。一共有4个定点，2个三角形，6个索引。&lt;/p&gt;

&lt;h4 id=&quot;line&quot;&gt;Line效果实现&lt;/h4&gt;
&lt;p&gt;这里需要一点点数学的知识，不知道大家还记不记得向量叉乘相关的知识，不记得的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%90%91%E9%87%8F%E7%A7%AF&quot;&gt;猛戳我&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;假设我们现在知道了line的起点，终点的位置，但是他并不是面向镜头的，我们现在要让他转向镜头，可以用下面的方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;计算出起点和终点的中点，并且和镜头位置相连接，得到向量1。&lt;/li&gt;
  &lt;li&gt;连接起点和终点，得到向量2。&lt;/li&gt;
  &lt;li&gt;向量1与向量2进行叉乘，我们得到一个垂直于他们的向量3。向量3需要标准化。&lt;/li&gt;
  &lt;li&gt;向量2作为轴，将line进行旋转，使得平面与向量3平行。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面四个步骤完成之后，我们就会发现line已经转向镜头了。这样我们无论怎么移动镜头，都是不会看到line的背面的。&lt;/p&gt;

&lt;p&gt;第四步旋转其实也非常简单，根据起点和终点的位置，起点和终点的宽度以及向量3就可以计算出line的四个顶点坐标，然后绘制即可。具体的代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;float halfTailWidth = TailWidth / 2;
float halfHeadWidth = HeadWidth / 2;
Vector3 viewer = Camera.main.transform.position - HeadPosition;
Vector3 lineDir = HeadPosition - TailPosition;
Vector3 direction = Vector3.Cross(viewer, lineDir).normalized;

m_Vertices[0] = TailPosition - direction * halfTailWidth;
m_Vertices[1] = TailPosition + direction * halfTailWidth;
m_Vertices[2] = HeadPosition - direction * halfHeadWidth;
m_Vertices[3] = HeadPosition + direction * halfHeadWidth;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;meshcombine&quot;&gt;创建一个MeshCombine&lt;/h4&gt;
&lt;p&gt;现在到了我们真正节约开销的部分了。之前提到过，在MeshCombine中需要有一个List&lt;BatchInfo&gt;，这个List中每一个元素代表需要batch到一起的对象。怎么样的对象需要batch到一起，很简单，就是他们的material和layer都是相同的。现在我们来看看BatchInfo的成员变量。&lt;/BatchInfo&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class BatchInfo
{
    public int Layer;
    public Material Material;
    public List&amp;lt;CombineInstance&amp;gt; CombineInstance = new List&amp;lt;CombineInstance&amp;gt;();
    public CombineInstance[] CombineInstanceArray = null;
    public Mesh Mesh;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中，Layer和Material都是相同的，ConbimeInstance是最终我们要combine在一起的物体对象集合，而Mesh就是combine出的结果，最终要绘制的东西，占用一个Draw Call的东西。&lt;/p&gt;

&lt;p&gt;需要注意的是，我们在Line Renderer的脚本中的Update函数中计算四个顶点的位置，而计算完位置之后才能进行绘制，所以在这个脚本中我们绘制的代码需要放在LateUpdate函数中，具体如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void LateUpdate()
{
    for (int i = 0; i &amp;lt; BatchList.Count; ++i)
    {
        var batchInfo = BatchList[i];
        if (batchInfo.CombineInstanceArray == null)
        {
            if (batchInfo.CombineInstance.Count &amp;lt;= 0)
            {
                if (batchInfo.Mesh != null)
                {
                    Destroy(batchInfo.Mesh);
                }
                BatchList.RemoveAt(i);
                --i;
                continue;
            }
            batchInfo.CombineInstanceArray = batchInfo.CombineInstance.ToArray();
        }
        if (batchInfo.Mesh == null)
        {
            batchInfo.Mesh = new Mesh();
        }
        batchInfo.Mesh.CombineMeshes(batchInfo.CombineInstanceArray, true, false);
        Graphics.DrawMesh(batchInfo.Mesh, Matrix4x4.identity, batchInfo.Material, batchInfo.Layer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;CombineMeshes函数就是把所有的Mesh合并成一个Mesh，DrawMesh就是讲Mesh绘制到屏幕上，占用一个Draw Call。&lt;/p&gt;

&lt;p&gt;到此为止，我们的优化和实现已经全部完成了，下面来看看性能对比。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;性能对比&lt;/h2&gt;

&lt;p&gt;我们先在安卓手机上创建2000个对象，并且挂载系统自带的Line Renderer，得到的性能图像如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/LineRenderer/system.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们只需要关注Camera.Render的耗时，因为这一项代表的就是draw call的耗时，也是我们可以优化的一项。我们发现数值大约为93ms。&lt;/p&gt;

&lt;p&gt;现在我们挂载自己的Line Renderer，也是2000个对象：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/LineRenderer/mine.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们发现Camera.Render的耗时只有0.49ms！！足足快了大约190倍！可见batch的强大之处。那么这是不是意味着我们的Line Renderer就完胜系统的呢？其实不是的，在GPU的消耗上，我们略微的输给了系统的，但是因为CPU才是主要影响性能的因素，所以我们会把大部分的注意力都放在CPU上面，换句话说，我们的Line Renderer是成功的。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;可能是长期在写业务逻辑的缘故，对于这样的优化以及改进我一开始是无从下手的。但当我们真正“入门”之后，会发现优化是一件非常有趣非常有成就感的事情，我也能够感受到自己是一名“程序员”而不是“码农”，我想，不停的超越也是写代码的乐趣之一吧。&lt;/p&gt;

</description>
        <pubDate>Wed, 27 Jul 2016 20:00:00 +0800</pubDate>
        <link>https://gougoumemeda.github.io/2016/07/27/Unity%E4%B8%ADLineRender%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BC%98%E5%8C%96/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2016/07/27/Unity%E4%B8%ADLineRender%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BC%98%E5%8C%96/</guid>
        
        <category>Unity</category>
        
        <category>技术</category>
        
        <category>腾讯</category>
        
        
      </item>
    
      <item>
        <title>鹅厂是个好地方</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“来腾讯实习快两周了，感触颇深。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;放假之前&lt;/h2&gt;

&lt;p&gt;其实给我Offer的也只有两个公司。一个是携程，还有一个就是腾讯了。虽然腾讯把我安排到了深圳，但毕竟是大厂，能进去总觉得有一种自豪感。所以两者之中，我还是毫不犹豫的选择了腾讯。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-1&quot;&gt;放假中&lt;/h2&gt;

&lt;p&gt;在去腾讯之前，去了一次欧洲。游玩了德国和荷兰，为时九天。荷兰的夜生活相当丰富，荷兰的法律相当开明，可能这也是uber遵循荷兰法律的原因之一吧。40欧就能看到真人AV秀，你值得拥有。&lt;/p&gt;

&lt;p&gt;应该算是第二次来深圳，上次来的时候还是大一暑假，也是南山，也是腾讯。两年之后故地重游，也就有了一丝亲切感。到住的地方是凌晨两点，因为深圳的暴雨，飞机延误了四个小时。住的地方很简陋，一张桌，一个衣柜，没了。第二天赶紧购置了一批生活用品，买了一张床上桌子，否则真的没有办法写代码。&lt;/p&gt;

&lt;p&gt;13号，周三，正式入职的一天。早上就一直在忙碌着各种手续，在腾大和科兴之间来回穿梭。在科兴吃了一顿午饭，竟然要30元，这让月薪不足3000的我怎么活下去？见到导师大约是下午两点半，高高瘦瘦，非常干净，说话声音很轻，一眼就可以看出来是一个二次元，有着二次元男性透露出的那种宅属性。公司配置的电脑相当给力，i7，960，16G，这个配置完全可以特效全开的玩守望先锋。想到这里，我不禁心里暗喜。&lt;/p&gt;

&lt;p&gt;你以为我就这样可以玩游戏了？公司的网络是不能访问外网的，需要配置各种代理。于是我的守望先锋计划整整延后了两周，终于在公司KM平台上找到了运行的方法。每天中午的午休时间就变成了我的战斗时间。&lt;/p&gt;

&lt;p&gt;导师人相当不错，培养思路非常清晰，第一周我熟悉一下Unity这个平台，然后开发一款游戏出来。我选择的是我大一做过的游戏是男人就坚持二十秒。其实游戏思路很简单，只是我要去慢慢熟悉这个平台。完成之后还没结束，我需要将其优化，通用化，增加他的鲁棒性和可拓展性。&lt;/p&gt;

&lt;p&gt;比如说，生成岩石的过程中，RockController来控制每一个独立的岩石，Pool控制所有岩石的初始化，销毁与复用，RockGenerator来设置每一波岩石的各个参数，比如速度，数量等，而SpawnManager就是真正让一波岩石移动的类。这样的结构用在这个项目上看上去有一点大材小用，但是当项目规模大了，这样的架构就非常有必要。&lt;/p&gt;

&lt;p&gt;腾讯的食堂味道也非常不错，每顿还会有免费的水果。除了价格比较贵，其他真的挑不出什么毛病。如果你加班到晚上八点之后，还会获得一张夜宵券，虽然叫夜宵券，但他是可以用来刷晚饭的，也就是说，免费请你吃一顿第二天的晚餐。&lt;/p&gt;

&lt;p&gt;之前在知乎上看到，如何评价2016年的腾讯。在回答中，大家基本上都是在表扬腾讯。BAT三家中，似乎腾讯已经成为了最出色的一家。来到腾讯之后，深觉腾讯的确是这样一家公司。有时候会抱怨他的收费贵，但是他是一家做实事的公司。你以为只有你们吐槽腾讯吗！每次在KM平台上都会看到腾讯自己人对自己产品的各种抱怨，当然也会有相关的负责人员及时反馈与修复，所以腾讯才能越来越壮大。&lt;/p&gt;

&lt;p&gt;我所在的部门是IEG，互动娱乐事业群，也就是做游戏，娱乐相关的。说来有点惭愧，我现在没有在玩任何一款腾讯系的游戏。有时候会想，腾讯在世界上游戏行业收入第一，那么为什么没有独立研发出现象级的游戏产品呢？我们耳熟能详的英雄联盟，CF都是其他公司开发，腾讯代理或者收购的。近来腾讯也收购了前段时间风靡全球的部落冲突的开发商supercell，但是在收购之后，又出来了Pokemon Go。大家总说腾讯喜欢抄，没错，可能就是因为这样的抄，让腾讯没有办法在游戏行业成为像暴雪那样的信仰公司。腾讯总是会去收购，代理一些成熟的，已经风靡的游戏，而不敢去接触一些未知的领域和挑战（比如AR技术Pokemon Go），可能这就是原因吧。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;放假之后&lt;/h2&gt;

&lt;p&gt;虽然两周时间已经很喜欢腾讯了，但是我还是想回上海，想和大伙儿们一起去网吧开黑，一起吃火锅，一起洗澡。在深圳觉得自己就是一个废人，除了上班就是看剧，除了看剧就是写博文，除了写博文就是打游戏，活生生的变成了葛优。&lt;/p&gt;

</description>
        <pubDate>Mon, 25 Jul 2016 20:00:00 +0800</pubDate>
        <link>https://gougoumemeda.github.io/2016/07/25/%E9%B9%85%E5%8E%82%E6%98%AF%E4%B8%AA%E5%A5%BD%E5%9C%B0%E6%96%B9/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2016/07/25/%E9%B9%85%E5%8E%82%E6%98%AF%E4%B8%AA%E5%A5%BD%E5%9C%B0%E6%96%B9/</guid>
        
        <category>生活</category>
        
        <category>腾讯</category>
        
        <category>工作</category>
        
        
      </item>
    
      <item>
        <title>告别浮夸，新版博客你好</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“总觉得自己的审美提高了一大步。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;正文&lt;/h2&gt;

&lt;p&gt;讲真，现在回过头看自己过去的那个个人主页，已经有点不堪入目了。bug相当多，而且操作也不友好，优化也做得很差。这次修改，不仅是想让自己网站变得更加干净，也希望自己能够更加简单一些吧。&lt;/p&gt;

&lt;p&gt;我使用的是&lt;a href=&quot;http://huangxuan.me&quot;&gt;Hux&lt;/a&gt;的网页作为参考，有关于任何技术方面的细节，可以去他的网站看。如果你也想做一个类似的博客，可以去clone他在github上面挂的模板。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;关于我的博客，如果你有任何问题，请联系gougoumemeda@sjtu.edu.cn&lt;/p&gt;

</description>
        <pubDate>Sun, 24 Jul 2016 20:00:00 +0800</pubDate>
        <link>https://gougoumemeda.github.io/2016/07/24/%E5%91%8A%E5%88%AB%E6%B5%AE%E5%A4%B8-%E6%96%B0%E7%89%88%E5%8D%9A%E5%AE%A2%E4%BD%A0%E5%A5%BD/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2016/07/24/%E5%91%8A%E5%88%AB%E6%B5%AE%E5%A4%B8-%E6%96%B0%E7%89%88%E5%8D%9A%E5%AE%A2%E4%BD%A0%E5%A5%BD/</guid>
        
        <category>Web</category>
        
        <category>技术</category>
        
        
      </item>
    
      <item>
        <title>iOS应用逆向工程</title>
        <description>&lt;p&gt;之前想深入理解一下iOS方面的知识，就看了《iOS应用逆向工程》这本书。不可否认，这本书是我目前为止看到过的有关iOS方面的最精彩的书籍之一了。&lt;/p&gt;

&lt;p&gt;原先对于iOS的了解，无非就是一些苹果公开的Api，以及AppStore等非常官方的东西。这本书讲逆向工程，也就是从一个hacker的角度来看待iOS系统。当然，要越过苹果的重重障碍，必要的一点就是先越狱，为此我也在淘宝上买了一部二手的iPhone4S来作为我的测试机。&lt;/p&gt;

&lt;p&gt;越狱后，突然间iOS系统就变得很透明了，原先不知道的文件结构现在都暴露在我们面前。其实和MacOS的文件结构还是比较类似的，自己随便看看就能大概知道什么文件夹下存放着什么信息。此外接触了一些新的工具，比如Theos，IDA，class-dump等。前者类似于Xcode，是一个开发工具，可以专门用来写Tweak，也就是我们常说的“插件”。后两者才是真正厉害的东西，IDA是一个反汇编工具，class-dump能分析出二进制文件中的头文件。有了这两个东西，理论上任何的二进制文件我们都能知道他的具体实现，就看我们读汇编的功力深不深了。&lt;/p&gt;

&lt;p&gt;之前对于调试工具都不太重视，也不太愿意在程序中打断点。这恰恰是逆向工程的核心之一，打断点是在分析程序的过程中非常好的习惯，在多接触了LLDB之后，发现打断点真的能够带我们慢慢了解一个程序，而不仅仅是停留在UI层面。配合debugserver工具，任何的应用我们都能让他“随时停止”。&lt;/p&gt;

&lt;p&gt;所以，在逆向工程中，流程大概是这样：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Reveal定位View&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;cycript测试这个View就是我们想要的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;找到这个View的Controller。如果是Button，找到他的响应函数，进入5&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;IDA+LLDB中找到这个Controller中的数据源&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改数据源或者响应函数，实现自己的想法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Theos写成Tweak&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;书上的案例我都跟着做了，挺有意思的。其中“将电子邮件自动标为已读”这个项目中，作者使用AlertView来选择一个电子邮件。我写的时候拓展成了UITableView，这样就可以选择多个电子邮件了。&lt;/p&gt;

&lt;p&gt;可惜的是，除了工具和汇编方面的知识，其他方面的我以后使用的地方估计不多了。当然这本书带给我的乐趣是相当多的，第一次见识到逆向的威力，也看到了iOS不为人知的一面，实在是让人兴奋。&lt;/p&gt;
</description>
        <pubDate>Tue, 31 May 2016 20:00:00 +0800</pubDate>
        <link>https://gougoumemeda.github.io/2016/05/31/iOS%E5%BA%94%E7%94%A8%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2016/05/31/iOS%E5%BA%94%E7%94%A8%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</guid>
        
        <category>iOS</category>
        
        <category>技术</category>
        
        <category>逆向</category>
        
        
      </item>
    
      <item>
        <title>SJTULost的一些体会</title>
        <description>&lt;p&gt;最近花了大约一个月的时间来开发这个SJTULost的项目，这个项目其实是我的数据库大作业，主要是一个交大学生使用的失物招领平台，从技术上介绍一下这个项目吧。&lt;/p&gt;

&lt;p&gt;前端，因为之前使用过一次React但是时间比较仓促，没有仔细的去研究过这个框架具体的使用方法。这次使用了React之后也搭配了Flux作为前端的框架。确实，有了Flux之后数据在前端的传递更加清晰，将Action和Store分隔开来的做法也使得代码有更强的可读性和可拓展性。当然，前端数据和后台数据放在了Action中完成，使用Ajax来对后台进行请求，返回的数据都是Json格式的。得到返回数据后再通知Store去更新其前端数据，并且显示在用户面前。&lt;/p&gt;

&lt;p&gt;Action里面主要分为两个部分，一个是UserAction，主要记录用户的操作，比如修改用户信息，登录等。还有一个叫InitializationAction，记录的是其他所有的操作，包括Finding和Found的读取，过滤，更新，查询等。&lt;/p&gt;

&lt;p&gt;Store的东西相对会多一点，数据库中每一个关系对象都会有一个Store，比如Finding，Found，ItemType和Place。同时，针对一些特定的功能我们也提供了其Store，比如Rank，后台将排好序的名字返回给前端，保存在Store中并最后显示。&lt;/p&gt;

&lt;p&gt;后台用的还是Django，一方面比较成熟，另一方面因为我之前也做过Django项目，所以学习成本会低很多。&lt;/p&gt;

&lt;p&gt;数据库的话，我一共建了五个表（不包括多对多关系的第三张表）。分别是Finding，Found，User，ItemType和Place。各个表之间的关系还是比较明确的。将Finding和Found分开也是因为这两者虽然字段很接近，但是其功能是截然不同的。&lt;/p&gt;

&lt;p&gt;接下来说说看这个项目中的一些难点。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;登录。项目中我没有自己设立登录系统，在User表中也是没有username和password这样的字段的。我使用的是交大的&lt;a href=&quot;http://developer.sjtu.edu.cn/wiki/JAccount&quot;&gt;Jaccount&lt;/a&gt;登录系统来进行判断用户的身份，也就是说，这个网站只有交大的同学才能够使用。Jaccount授权系统使用的是OAuth2，因为之前没有熟悉过，所以在开发的时候还是遇到了一些问题的，比如authorization和access token的两个url的回调函数必须是一致的，否则没有权限获取access token。得到用户信息之后，判断用户是否存在于数据库，如果不存在就创建一个新的元组。同时将这个用户在User表中的id保存在session里，有效期为两周，因此在两周内用户是不需要登录的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;搜索。问题在于用户输入多个关键字时，我们应该怎么看待这些关键字的关系，是同时满足还是至少满足一个。因此我将与运算和或运算都加入到搜索系统里面，方便用户的查询。在后台使用queryset的field_contain参数，就能够从数据库里获取想要的信息。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分页。分页的问题在于，我们除了需要获取那些部分的数据之外，还要获得所有数据的总数，这样才能知道什么时候用户是没有办法点击下一页的。我现在的实现中还存在着一个问题，用户每一次点击一页，相当于是重新计算了一遍再把数据返回前台。我理想的结果是，用户进入第一页之后，后台先返回第一页，然后在将后面一部分的页面读取出来缓存起来，这样如果用户点击下一页就不需要重新计算了，可以直接将数据返回前端。如果用户点击到了没有缓存过的一页，则再计算一遍。这样我们实际是利用用户浏览的时间才读取后面的内容，减少网页响应时间。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选取时间。在网上找过一些时间的插件，但是都是用jQuery实现的，React版本的时间插件并不流行。最后选择了&lt;a href=&quot;https://github.com/YouCanBookMe/react-datetime&quot;&gt;react-datetime&lt;/a&gt;这个插件，能够和我的项目兼容。其中有一些props可以传递，包括dateFormat，timeFormat之类，都是可以在moment.js的网站上找到相应的字符格式。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;上传图片。抱歉，我实在没找到合适的React的上传文件的插件，因此还是用jQuery写成的&lt;a href=&quot;https://github.com/blueimp/jQuery-File-Upload&quot;&gt;jQuery-File-Upload&lt;/a&gt;插件。不过我将上传的动作放在了Action里，使得除了Action文件以外的地方都不会出现$这个符号。将图片传递给后台之后，使用qiniu的Python SDK将其上传到七牛云。最后把照片的url返回给前端，实时预览。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于这个项目的大概就是这些，如果有问题的话可以联系我。&lt;/p&gt;

&lt;p&gt;项目目前还没有服务器，有没有老司机推荐一个能跑python的，便宜的，免备案的服务器？&lt;/p&gt;
</description>
        <pubDate>Sat, 21 May 2016 20:00:00 +0800</pubDate>
        <link>https://gougoumemeda.github.io/2016/05/21/SJTULost%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%93%E4%BC%9A/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2016/05/21/SJTULost%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%93%E4%BC%9A/</guid>
        
        <category>Javascript</category>
        
        <category>技术</category>
        
        <category>Python</category>
        
        <category>Web</category>
        
        
      </item>
    
      <item>
        <title>关于Django, React和Flux的一些思考</title>
        <description>&lt;p&gt;最近在用Django作为后端写一个SJTU Lost的Web应用，主要是一个失物招领的平台吧，交大学生如果丢了什么东西可以发布过去，如果捡到什么东西也可以在上面贴出来。&lt;/p&gt;

&lt;p&gt;然而我在做的过程中遇到了不少的问题。&lt;/p&gt;

&lt;p&gt;首先，Django这个后端框架我还是比较熟悉的，外接了MySQL数据库之后，后台并没有遇到太大的问题。然而在选择前端的框架是我纠结了很久：是使用比较传统简单的jQuery还是比较新但是上手比较困难的React？最终我还是选择了React，算是给自己的一个挑战，也是让我接触新知识的一个很好的机会。毕竟以后web component是一种趋势，而jQuery终究会过时。&lt;/p&gt;

&lt;p&gt;实际上，ReactJS只是一个View的框架，他能很好的帮助我们创建组件视图，但是并不能够很优雅的保存一些状态与数据，在处理一些交互动作时也显得略微笨重。在React这个前端技术栈中，现在比较流行的是React+Flux+ReactRouter。&lt;/p&gt;

&lt;p&gt;Flux实际上提供了单向数据流的传递方案，Action，Dispatcher和Store能够很好的解决React中没办法保存状态数据的问题。&lt;/p&gt;

&lt;p&gt;大概流程是，用户在View上点击一个按钮，产生一个Action，Action会调动Dispatcher来分发相应的数据，Store中数据的改变又会让View进行更新，最终显示用户想要的内容在页面上。&lt;/p&gt;

&lt;p&gt;ReactRouter我并没有使用，简单来说就是定义一些url和相应显示的component。因为Django自带有router功能，所以我直接把这部分抛弃了。&lt;/p&gt;

&lt;p&gt;要安装Flux和ReactJS的话最好还是使用npm，所以引入了一部分nodejs的知识，其实也就是很简单的require一个模块方面的内容，但是作为一个从来没有用过nodejs的人，我发现浏览器没有办法识别出require函数。。。搜索资料过后，发现要先用browserify/webpack将其打包，并且用执行的工具将代码编译成浏览器能识别的js文件。前者是比较传统的工具，缺点是很多东西不支持，比如jsx。后者可以自己定制想要的效果，保存在webpack.config.js文件中，因此最终选择了后者。ES6语法转换成ES5语法直接用Babel就好了，jsx文件也有对应的jsx-loader！&lt;/p&gt;

&lt;p&gt;好，介绍完了技术背景之后，我来说一下我遇到的问题和一些思考。&lt;/p&gt;

&lt;p&gt;如何在整个浏览器生命周期中共享一份Store/Action/Dispatcher?&lt;/p&gt;

&lt;p&gt;其实这个问题非常的普遍。我们第一次进入一个页面后，将一部分信息保存在Store里面。如果我们导航到这个页面的一个子页面，我们还是希望能够继续得到这部分信息的。如果重新跟后台请求，那会再一次产生网络负担，而如果这部分信息能一直保存在Store中的话，就节约了这部分开销，相当于缓存在浏览器中。&lt;/p&gt;

&lt;p&gt;但是！我并没有找到合适的解决方案，目前进入不同的页面还是会产生一个新的Store实例，然后从后台得到相应的数据。我觉得Flux设计的理念是和我想的一样的，但是我没有办法在Django框架下解决这个问题（除非我们写单页应用，即只有一个url，那我们在一个js文件中只需要require一次，相应的Store/Action/Dispatcher肯定也只有一个了）。Django的路由决定了视图，因此切换到不同的url时，视图会被加载，视图中的js文件也会被加载（即使是相同的视图也会重新加载一次，导致了新的实例的产生）。当然我知道现在很多跨url保存一些数据（比如购物车里的东西）比较常见的做法是使用cookie，之后如果时间充足应该也会考虑这样的做法（其实可以用session来存放，但是那样我就感觉Flux没啥存在的价值。。。）&lt;/p&gt;

&lt;p&gt;现在有一个导航栏，如何保证在所有页面中我们使用的是一个导航栏(减少加载)?&lt;/p&gt;

&lt;p&gt;这个问题本质和问题1是一样的，每一次访问一个Django的新路由，都会加载或者重新加载一个视图，只要导航在这个视图中，就会重新加载。&lt;/p&gt;

&lt;p&gt;如果要解决这个问题，第一是可以考虑用Ajax，但是这样的话就只能使用一个url了。&lt;/p&gt;

&lt;p&gt;还有一种方法是使用Pjax，这是pushState+Ajax，可以在改变url的同时异步加载网页一部分内容。事实上在之前是有一个Django-Pjax的，但是作者已经很久没有更新了，似乎已经不支持现有的版本了。如果之后有时间的话也会去尝试一下这个库。&lt;/p&gt;

&lt;p&gt;现在还没有解决这个问题，也希望大家能够帮我想想办法。&lt;/p&gt;

&lt;p&gt;大概就是这样，明天继续填坑。&lt;/p&gt;
</description>
        <pubDate>Mon, 25 Apr 2016 20:00:00 +0800</pubDate>
        <link>https://gougoumemeda.github.io/2016/04/25/%E5%85%B3%E4%BA%8EDjango,-React%E5%92%8CFlux%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2016/04/25/%E5%85%B3%E4%BA%8EDjango,-React%E5%92%8CFlux%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</guid>
        
        <category>Javascript</category>
        
        <category>技术</category>
        
        <category>Python</category>
        
        <category>Web</category>
        
        
      </item>
    
      <item>
        <title>Objective-C中的系统框架</title>
        <description>&lt;p&gt;iOS开发中有两个最重要的系统框架: Foundation和CoreFoundation，前者定义了OC对象，后者是C语言的API和数据结构。对于Foundation中的每一个OC对象，我们都有一个对应的CoreFoundation数据结构，使用__bridge可以进行无缝桥接：&lt;/p&gt;

&lt;p&gt;__bridge: ARC仍然具备这个OC对象的所有权&lt;/p&gt;

&lt;p&gt;__bridge_retained: ARC交出这个OC对象的所有权，我们需要手动Release&lt;/p&gt;

&lt;p&gt;__bridge_transfer: ARC获得对象的所有权&lt;/p&gt;

&lt;p&gt;在OC中，我们遍历一个Collection有以下几种方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;常规的for循环，和C语言一样&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;NSEnumerator来遍历：nextObject方法来返回枚举里的下个对象，最后一个对象则返回nil&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;快速遍历：for…in&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;块遍历：enumerateObjectsUsingBlock, enumerateKeysAndObjectsUsingBlock&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;块遍历可以提供对象，下标和指向是否终止的布尔值的指针。&lt;/p&gt;

&lt;p&gt;在进行网络请求下载资源的时候，我们通常会把内容缓存下来。这时候应该采用NSCache。NSCache会在系统资源将要耗尽的时候，自动删减缓存。我们可以设置NSCache的对象的上线和总成本，来定义缓存删减其中对象的时机。&lt;/p&gt;

&lt;p&gt;initialize和load方法是OC对象两个比较特殊的初始化方法。前者在第一次使用对象的时候调用，后者在APP启动的时候调用。需要注意的是，这两个方法都是阻塞的，因此我们不能放太多的操作在这两个方法之中。在load方法中我们不能调用其他类中的方法，因为初始化的顺序和时机是程序员不能确定的。&lt;/p&gt;
</description>
        <pubDate>Wed, 13 Apr 2016 20:00:00 +0800</pubDate>
        <link>https://gougoumemeda.github.io/2016/04/13/Objective-C%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2016/04/13/Objective-C%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6/</guid>
        
        <category>iOS</category>
        
        <category>技术</category>
        
        <category>Objective-C</category>
        
        
      </item>
    
      <item>
        <title>Objective-C中的协议和分类</title>
        <description>&lt;p&gt;delegate也是iOS编程中的一个重点，他定义了一套接口，如果一个对象想接受另一个对象的委托，则需要遵从此接口，以便成为其委托对象。这个委托的意思，实际上就是把函数的实现写在另一个类中，这个函数可以使用那个类的方法和数据成员。看上去就像是这个类帮别人做了写事情，成为委托的对象。委托的协议用@protocal来定义，在存放委托对象的类中，可以这么写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weak&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SomeProtocal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delegate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们必须用weak修饰符来避免循环引用。上述代码的id指向遵循这个协议的类，表示我们不关心这个类具体是什么，我们只注意到这个类遵循了这个协议。当然，对于可选的方法，我们在前面加上@optional即可。&lt;/p&gt;

&lt;p&gt;下面来说说分类这个东西。OC中的分类对应swift就是其extension。我们可以通过分类把类实现代码按照逻辑分散到几个文件中:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;AboutSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;分类中的方法是直接添加在类里面的，就好比是这个类的固有方法，因此会有覆写的可能性。需要注意的一点是，我们不要在分类中声明属性，因为在分类中是不能添加实例变量的。那不代表不能声明属性，通过@dynamic关键字，或者关联对象，都能够解决这个问题。但是保险起见，还是不要声明属性。当然，不是说所有的分类都不能，有一种分类叫做class-continuation就是例外，他有如下的特点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;必须定义在其所接续的那个类的实现文件里&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;唯一能够声明实例变量的分类&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分类没有名字&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分类中的所有属性和方法都是隐藏的，只能在本类中使用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可以修改某属性的读写性，只读的属性可以在此分类中扩展为可读写&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;比如这样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然，协议也可以隐藏在class-continuation中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SomeProtocal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 04 Apr 2016 20:00:00 +0800</pubDate>
        <link>https://gougoumemeda.github.io/2016/04/04/Objective-C%E4%B8%AD%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%88%86%E7%B1%BB/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2016/04/04/Objective-C%E4%B8%AD%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%88%86%E7%B1%BB/</guid>
        
        <category>iOS</category>
        
        <category>技术</category>
        
        <category>Objective-C</category>
        
        
      </item>
    
  </channel>
</rss>
