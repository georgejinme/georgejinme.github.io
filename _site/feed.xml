<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GeorgeJin</title>
    <description>My personal webpage</description>
    <link>https://gougoumemeda.github.io/</link>
    <atom:link href="https://gougoumemeda.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 17 Dec 2017 16:02:31 +0000</pubDate>
    <lastBuildDate>Sun, 17 Dec 2017 16:02:31 +0000</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>Wap STM中随手写的一些web库</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;十一长假结束后，公司STM的第二个assignment也要进入尾声了。有了第一个assignment的经验，这次在具体开发的过程中遇到的问题就少了很多，我也把更多的重心放在了组件化上，尝试着去写一些公共的库文件来供他人使用。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;正文&lt;/h2&gt;

&lt;p&gt;在这次的开发中，我一共提取出了三个公共库，分别与滑杆，分页器与图表有关。我将其相关的代码写在各自的文件中，使用一个类来封装，其他人使用时，只需要声明一个新的对象然后传入相应的参数即可，不需要关注其具体的实现。下面我将各自介绍这些库的实现细节与使用方法。&lt;/p&gt;

&lt;h3 id=&quot;slider&quot;&gt;Slider&lt;/h3&gt;
&lt;p&gt;这是一个滑杆库，&lt;a href=&quot;/js/slider.js&quot;&gt;点我下载slider.js&lt;/a&gt;。目前该slider使用的是双向设计，即有两个滑块，他们中间的范围为最终我们需要的值，设计图如下所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/WAP/slider.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所接受的参数如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;config: {
    name: string, // 该slider的名字
    target: jQuery Object, // 该slider所要放置的jQuery对象
    width: float, // slider的宽度
    height: float, // slider的高度
    barHeight: float, // slider中滑杆的高度，该值需要小于height
	extremum: { // slider的两个端值
        l: float,
        r: float
    },
    initial: { // slider的两个初始值
        l: float, 
        r: float
    },
    beginDrag: function, // 开始滑动滑块时触发的操作
    endDrag: function // 结束滑动滑块时触发的操作
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;整体实现的思路非常清晰，大致如下：
- 绘制滑杆，并且上色
- 根据slider的宽度、端值以及初始值绘制左滑块与右滑块
- 在左滑块与右滑块的中间添加一个&lt;code class=&quot;highlighter-rouge&quot;&gt;validZone&lt;/code&gt;，表示当前有效的范围，高度为&lt;code class=&quot;highlighter-rouge&quot;&gt;barHeight&lt;/code&gt;，并且进行上色（配色尽量与滑杆的颜色进行搭配）
- 绘制滑块Label，显示当前的数值
- 绑定事件&lt;/p&gt;

&lt;p&gt;在实现的过程中并没有太多困难的地方，唯一可能牵扯到一些数学知识的，应该就是计算滑块的位置。我们以左滑块为例，如果要计算它的初始位置，则公式如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(initial.l - extreme.l) / (extreme.r - extreme.l) * width
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;同理，如果我们已知左滑块的位置，要计算左滑块的值，可以通过如下的公式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extreme.l + (leftPos / width) * (extreme.r - extreme.l)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在滑块滑动的过程中，我们会经常用到上述的两个公式，因此需要掌握其背后的原理（也是非常显而易见的）。&lt;/p&gt;

&lt;h3 id=&quot;pagination&quot;&gt;Pagination&lt;/h3&gt;

&lt;p&gt;在大学期间，我已经多次实现过分页器，但是都没有将其独立的作为一个模块拎出来。这一次用类来封装，也是希望能够测验一下自己对分页器的理解。&lt;/p&gt;

&lt;p&gt;很久之前就聊过，分页器分为前端分页和后端分页。在本项目中，由于我们没有构建一个独立的服务端，因此这里实现的分页器采用的是前端分页。后端分页如果要实现的话，对数据层的控制力度可能就要小一些，因为所有的数据都是从后台传进去的，分页器只是做了一个显示的作用。而前端分页不仅仅是显示，真正的分页过程也在这里进行，因此对分页器的封装更加友好。需要使用的朋友可以&lt;a href=&quot;/js/pagination2.js&quot;&gt;点我下载pagination.js&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;最终的设计图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/WAP/pagination.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所接受的参数如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;config: {
    name: string, // 分页器的名字
    target: jQuery.Object, // 分页器要放置的jQuery对象
    data: [], // 分页数据
    maxNumberOfButton: int, // 分页器最多同时显示的页码数量
    eachPageNumber: int, // 每个页面的条目数量
    clickEvent: function // 点击分页器页码时触发的操作
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;实现的思路如下：
- 初始化分页器，计算总共的页码数量，分页器同时显示的页码数量（小于或者等于&lt;code class=&quot;highlighter-rouge&quot;&gt;maxNumberOfButton&lt;/code&gt;）以及所要显示的页码。
- 绘制分页器。如果是第一页，则向左按钮失效（添加类&lt;code class=&quot;highlighter-rouge&quot;&gt;disabled&lt;/code&gt;），如果是最后一页，则向右按钮失效
- 点击事件，对传入的数据进行分页，并且重新绘制分页器。&lt;/p&gt;

&lt;p&gt;相对来说，比较复杂的在于第三步点击事件，这里我们需要重新计算所要显示的页码。定义当前页码为&lt;code class=&quot;highlighter-rouge&quot;&gt;curr&lt;/code&gt;，所要显示的页码数量的一半为&lt;code class=&quot;highlighter-rouge&quot;&gt;mid&lt;/code&gt;，总页码数为&lt;code class=&quot;highlighter-rouge&quot;&gt;total&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;maxNumberOfButton&lt;/code&gt;小于&lt;code class=&quot;highlighter-rouge&quot;&gt;total&lt;/code&gt;，那么我们可能会隐藏一部分页码不显示。例如，我们最大能够显示的页码量为5，但是这时候一共有7页，那么初始情况下需要显示的页码为1，2，3，4，5。第六页和第七页我们将其隐藏。如果我们单击页码4，那么需要显示的页码就变成了2，3，4，5，6。&lt;/p&gt;

&lt;p&gt;大致上来看，我们可以将需要显示的页码分为三类，则：
1. &lt;code class=&quot;highlighter-rouge&quot;&gt;curr &amp;gt;= 1 &amp;amp;&amp;amp; curr &amp;lt;= mid&lt;/code&gt;，则需要显示的页码为&lt;code class=&quot;highlighter-rouge&quot;&gt;1 ~ maxNumberOfButton&lt;/code&gt;。
2. &lt;code class=&quot;highlighter-rouge&quot;&gt;curr &amp;lt;= total &amp;amp;&amp;amp; curr &amp;gt;= total - mid + 1&lt;/code&gt;，则需要显示的页码为&lt;code class=&quot;highlighter-rouge&quot;&gt;total - maxNumberOfButton + 1 ~ total&lt;/code&gt;
3. 除此之外，需要显示的页码为，&lt;code class=&quot;highlighter-rouge&quot;&gt;curr - mid ~ curr + mid (- 1, 当maxNumberOfButton为偶数时)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以看到，在第三种情况中，当前的页码始终处于分页器的中间位置。&lt;/p&gt;

&lt;p&gt;整个分页器的难点就在于理清楚这三种情况。对于后端分页，我们就不再需要传入data，也不需要实际的分页操作，仅仅绘制分页器即可。&lt;/p&gt;

&lt;h3 id=&quot;chart&quot;&gt;Chart&lt;/h3&gt;

&lt;p&gt;图表是最为难以实现的一个模块库。在本项目中，我一共实现了三种类型的图表，无论从种类上还是性能上，都无法与市面上目前已经成熟的图表类库进行比较（例如acharts）。因此，对于我个人而言，这是一个完成项目所必须完成的工作，也是锻炼我js能力的一次考验。&lt;/p&gt;

&lt;p&gt;我将三种类型的图表写在了同一个文件中，&lt;a href=&quot;/js/chart.js&quot;&gt;点我下载chart.js&lt;/a&gt;，下面我将一个一个介绍。&lt;/p&gt;

&lt;h4 id=&quot;histogram-bar-chart&quot;&gt;Histogram （这里译名有点奇怪，我的锅，其实就是bar chart）&lt;/h4&gt;

&lt;p&gt;先来看一张效果图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/WAP/histogram.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所接受的参数如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;config: {
	name: string, // 柱状图的名字
	target: jQuery Object, // 柱状图所要放置的jQuery对象
	height: int, // 柱状图的高度
	width: int, // 柱状图的宽度
	legend: string, // 图例
	clickEvent: function, // 点击柱状图事件
	color: string, // 柱状图的颜色
	xAsix: Array, // 横坐标数据
	yAsix: Array // 横坐标数据所对应的值
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;实现的思路如下：
- 初始化坐标系，确定纵坐标的方向（正/负/双向）。
- 绘制图例
- 绘制纵坐标，根据&lt;code class=&quot;highlighter-rouge&quot;&gt;yAsix&lt;/code&gt;计算出纵坐标的最大值以及划分线的数量
- 绘制横坐标，动态绘制柱状条，并且在柱状体条上方添加数值标签
- 绑定鼠标覆盖事件以及点击事件&lt;/p&gt;

&lt;p&gt;其中，最为复杂的应该是绘制纵坐标以及动态绘制柱状条这两步。&lt;/p&gt;

&lt;p&gt;在绘制纵坐标中，我们需要先确定坐标轴的最大值。我们简单的通过yAsix中的最大值的最高位加一的方法来确定纵坐标端值。比如，如果&lt;code class=&quot;highlighter-rouge&quot;&gt;yAsix&lt;/code&gt;中最大值为75000，则坐标轴的最大值为80000；如果是98000，则最大值为100000。负数亦然，我们得到了&lt;code class=&quot;highlighter-rouge&quot;&gt;_yPositivePeak&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;_yNegativePeak&lt;/code&gt;。接着我们需要计算出纵坐标轴正负两端划分线的数量。对于正负两端最大值数位多的那一端（假设为正方向端，即 &lt;code class=&quot;highlighter-rouge&quot;&gt;_yPositivePeak.str().length &amp;gt; _yNegativePeak.str().length&lt;/code&gt;)，其划分线的数量就是最高位（例外是，如果最高位为1，则数量为10）；数位少的那一端，通常情况下划分线的数量就是1。举个例子， &lt;code class=&quot;highlighter-rouge&quot;&gt;_yPositivePeak&lt;/code&gt;为70000， &lt;code class=&quot;highlighter-rouge&quot;&gt;_yNegativePeak&lt;/code&gt;为-3000，则正方向的划分线数量为7，具体是10000，20000，30000，40000，50000，60000，70000；负方向的划分线数量为1，具体是-3000。&lt;/p&gt;

&lt;p&gt;细心的读者可以发现，对于数位少的一端，我在划分线数量为1的前面加了一个定语“通常”，也就是说，有例外发生。这种情况出现在，两端最大值数位差为1，并且数位多的那一端的最高位为1（即 &lt;code class=&quot;highlighter-rouge&quot;&gt;_yPositivePeak.str().length - _yNegativePeak.str().length == 1 &amp;amp;&amp;amp; _yPositivePeak.str()[0] == &#39;1&#39;&lt;/code&gt;)。再这样的情况下，数位少的那一端划分线的数量也是其最高位。比如说， &lt;code class=&quot;highlighter-rouge&quot;&gt;_yPositivePeak&lt;/code&gt;为100000， &lt;code class=&quot;highlighter-rouge&quot;&gt;_yNegativePeak&lt;/code&gt;为-40000，则正方向的划分线数量为10，具体是10000，20000，30000，40000，50000，60000，70000，80000，90000，100000；负方向的划分线数量为4，即-10000，-20000，-30000，-40000。&lt;/p&gt;

&lt;p&gt;这么设计看上去会有一些复杂，但是为了坐标轴更为美观，采用这样的方法我认为是很有必要的。他避免了两个问题：
1. 两端端值数位相差过大时，数位小的那一端划分线过于紧凑
2. 两端端值数位相差不大时，数位小的那一端划分线过于松散&lt;/p&gt;

&lt;p&gt;一句话来概括的话，就是正负两端划分线的间距要尽量保持一样，如果正方向划分线的间距时10000，那么负方向也要保持10000，否则就不划分（划分线数量为1）。这是一种保证柱状图坐标轴不会太丑的方法。&lt;/p&gt;

&lt;p&gt;第二个难点在于，如何动态绘制柱状条。这里我们用到了css3中的&lt;code class=&quot;highlighter-rouge&quot;&gt;-webkit-transition&lt;/code&gt;。我们对每一个柱状条进行如下的css设置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.bar{
    height: 0;
    &#39;-webkit-transition&#39;: &#39;height 1s&#39;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在将其加入到dom树之后，修改他的height为实际的高度，就能触发动画效果。&lt;/p&gt;

&lt;h4 id=&quot;pie-chart&quot;&gt;Pie chart&lt;/h4&gt;

&lt;p&gt;现在我们将介绍饼图，老样子还是先看图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/WAP/piechart.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所接受的参数如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;config: {
	name: string // 饼图的名字
	target: jQuery Object, // 饼图所放置的jQuery对象
	height: int, // 饼图的高度
	width: int, // 饼图的宽度
	legend: string, // 图例
	clickEvent: function, // 点击事件 
	data:[{ // 饼图的数据，包括文字描述，数据以及扇形的颜色
		label: string,
		value: int,
		color: string
	}]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;实现的思路如下：
- 初始化饼图，这里我们使用canvas来绘制
- 绘制饼图。如果是第一次绘制，则使用动画效果
- 绑定鼠标移动事件，在移动的过程中不停的重绘饼图，同时判断鼠标的位置是否在某一个扇形路径内，如果在，则可认为当前鼠标的位置覆盖了该扇形
- 绑定鼠标点击事件&lt;/p&gt;

&lt;p&gt;在饼图中，最为复杂的一点在于如何判断鼠标是覆盖了哪一块扇形。因为扇形是不规则的，我们不能像柱状图那样使用div来绘制，因此只能够使用canvas。而在canvas中，所有的图像都是一个整体，没有办法对每一个扇形进行单独的事件绑定，而需要通过&lt;code class=&quot;highlighter-rouge&quot;&gt;canvas.getContext(&#39;2d&#39;).isPointInPath(x, y)&lt;/code&gt;来判断一个坐标是否在canvas中的某一个路径内。在饼图中，我们按照顺时针的方向来绘制扇形，扇形路径绘制完毕后，我们马上进行&lt;code class=&quot;highlighter-rouge&quot;&gt;isPointInPath()&lt;/code&gt;的判定，就能够知道鼠标当前所覆盖的扇形是哪一个。这也就需要在mousemove事件中不停的重绘饼图，因为鼠标的坐标是不停的变化的。我原本以为这种方法的性能消耗会非常大，但事实上来看似乎并没有卡死的现象。如果有更好的方法也希望大家能够告知。&lt;/p&gt;

&lt;p&gt;除了判断鼠标位置所在的扇形之外，另一个有点难度的地方在于如何动态绘制饼图。所谓动态绘制，就是一点一点的来画图。原本可能90°的扇形一次性画完，动态绘制就将其分成90份，每次只绘制1°的扇形，重复绘制90次。理所应当的我们需要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;setInterval&lt;/code&gt;函数，来重复绘制操作。绘制之前，我们先顺时针扫一遍所有的扇形，然后将扇形的终弧度保存在一个数组&lt;code class=&quot;highlighter-rouge&quot;&gt;angles&lt;/code&gt;中，以备后用，同时记录下当前正在绘制的度数 _timerCurrDraw。在具体的小角度的绘制过程中，我们先判定当前绘制的是哪一个扇形（通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;_timerCurrDraw&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;angles&lt;/code&gt;中的元素进行比较），来决定绘制的颜色，然后进行path的绘制并且上色即可。如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;_timerCurrDraw&lt;/code&gt;大于了最后一个扇形的终弧度（为2π），则动态绘制结束。&lt;/p&gt;

&lt;h4 id=&quot;scatter-diagram&quot;&gt;Scatter diagram&lt;/h4&gt;
&lt;p&gt;翻译上来看，就是所谓的散点图，但其实与我们常见的散点图还有一些区别。除了点的分布以外，我所设计的scatter diagram还将空间分成了四个部分，每个部分都有其实际意义。对于点的分布，我也添加了一些新的含义，不同的颜色表示点不同的种类，而点的颜色深浅与半径的大小也区分了其在该类型中的等级。&lt;/p&gt;

&lt;p&gt;效果图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/WAP/scatter.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所接受的参数如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;config: {
	name: string // 散点图的名字
	target: jQuery Object, // 散点图所在的jQuery对象
	height: int, // 散点图的高度
	width: int, // 散点图的宽度
	group: [{ // 散点图中的各个类型，并且赋予其坐标
		x: float,
		y: float,
		label: string,
		color: string
	}]
	clickEvent: function, // 点击事件
	data:[{ // 各个点的坐标数值以及介绍
		x: float,
		y: float,
		info: string
	}],
	meaning: { // 坐标的含义
		x: string,
		y: string,
		xRate: bool,
		yRate: bool
	},
	zones: { // 散点图的四个区域的名称以及含义
		lt: string,
		ltexp: string,
		rt: string,
		rtexp: string,
		lb: string,
		lbexp: string,
		rb: string,
		rbexp: string
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;实现的思路如下：
- 初始化坐标轴，计算出&lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt;中坐标进行平移的向量以及拉伸的系数，使之能够撑满&lt;code class=&quot;highlighter-rouge&quot;&gt;width&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;height&lt;/code&gt;
- 绘制坐标轴，解释坐标的含义并且画上划分线
- 绘制四个区域
- 对所有的散点进行分类
- 绘制坐标点，通过到类型坐标的距离来决定其颜色深浅和半径大小
- 绘制图例
- 绑定散点的覆盖和点击事件&lt;/p&gt;

&lt;p&gt;其中，最为复杂的，之一在于坐标轴的平移与拉伸。在本项目中，我们散点的横坐标与纵坐标都是百分数，也就是-1 ~ 1的区间，没有办法直接在图中转换为像素值，进行绘制。因此我们最先要做的，是将这些百分数的值转换成实际所要绘制的坐标值。在转换之前，我们需要计算一些初始数据：散点横纵坐标各自的最大值与最小值&lt;code class=&quot;highlighter-rouge&quot;&gt;maxX&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;maxY&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;minX&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;minY&lt;/code&gt;；散点的中心位置坐标&lt;code class=&quot;highlighter-rouge&quot;&gt;_graphCenterX&lt;/code&gt;， &lt;code class=&quot;highlighter-rouge&quot;&gt;_graphCenterY&lt;/code&gt;；实际坐标系的中心位置 &lt;code class=&quot;highlighter-rouge&quot;&gt;_centerX&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;_centerY&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;通过这些值，我们需要算出如下信息：
1. 每一个散点在实际坐标系的位置&lt;code class=&quot;highlighter-rouge&quot;&gt;(data[index].x - _graphCenterX, data[index].y - _graphCenterY)&lt;/code&gt;
2. 拉伸系数。&lt;code class=&quot;highlighter-rouge&quot;&gt;_graphScaleX = width / (maxX - minX)&lt;/code&gt;; &lt;code class=&quot;highlighter-rouge&quot;&gt;_graphScaleY = height / (maxY - minY)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后在计算散点实际绘制的坐标过程中，我们只需要对每一个散点在实际坐标系的位置先进行拉伸（将其乘上 &lt;code class=&quot;highlighter-rouge&quot;&gt;_graphScaleX&lt;/code&gt;和 &lt;code class=&quot;highlighter-rouge&quot;&gt;_graphScaleY&lt;/code&gt;）,然后按照一个方向向量进行平移（加上 &lt;code class=&quot;highlighter-rouge&quot;&gt;_centerX&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;_centerY&lt;/code&gt;)即可。&lt;/p&gt;

&lt;p&gt;之二在于散点的分类和绘制。对于点的分类，我采用的是类knn算法。每一种类型，我们都赋予其一个实际的坐标值&lt;code class=&quot;highlighter-rouge&quot;&gt;(group[index].x, group[index].y)&lt;/code&gt;，而对于每一个散点，我们计算出他到各个类型的坐标的距离，取其最短，将该散点归类到该类型中。在同一种类型中，我们计算出其中所有的散点到类型坐标的距离，根据距离的长短来决定其颜色深浅以及半径大小，完成最终的绘制。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;使用说明&lt;/h3&gt;

&lt;p&gt;至此，在本项目中封装好的类都已经介绍完毕了。使用方法大同小异：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a = new B({
    ... // 根据每一个类传入所需要的参数值
})
a.render()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行上述代码后就能正常使用该类了。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;NONE&lt;/p&gt;

</description>
        <pubDate>Mon, 09 Oct 2017 16:17:00 +0000</pubDate>
        <link>https://gougoumemeda.github.io/2017/10/09/Wap-STM%E4%B8%AD%E9%9A%8F%E6%89%8B%E5%86%99%E7%9A%84%E4%B8%80%E4%BA%9Bweb%E5%BA%93/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2017/10/09/Wap-STM%E4%B8%AD%E9%9A%8F%E6%89%8B%E5%86%99%E7%9A%84%E4%B8%80%E4%BA%9Bweb%E5%BA%93/</guid>
        
        <category>Works Applications</category>
        
        <category>Web</category>
        
        <category>技术</category>
        
        
      </item>
    
      <item>
        <title>Wap STM Web开发心得</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;这一周其实过的很不好，算是自己近两年来，心情最糟糕的一周。&lt;/p&gt;

&lt;p&gt;我一直告诉自己，活到现在，其实是没有什么事情需要后悔的。如果有第二次机会的话，我想收回上周三晚上说的所有的话，对不起。&lt;/p&gt;

&lt;p&gt;所谓冲昏了头脑，大抵如此。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;正文&lt;/h2&gt;

&lt;p&gt;这一个月里，一直都在做一个Personal Information System。做的过程中因为是不允许上网的，所以还遇到了不少的问题要去解决。本文就具体介绍一下这些问题，以后遇到的时候也有一个解决方案。&lt;/p&gt;

&lt;p&gt;当然，由于公司要求保密，因此相关的细节代码不会公开。&lt;/p&gt;

&lt;h3 id=&quot;webkitrequestfilesystem&quot;&gt;使用webkitRequestFileSystem来导出文件&lt;/h3&gt;

&lt;p&gt;这部分是HTML5的File API的部分。之前在我印象中，只有IE有相应开放的接口来操作本地文件的。HTML5出来之后，主流的浏览器都已经支持这样的操作了，像是webkit内核的chrome浏览器等。&lt;/p&gt;

&lt;p&gt;由于该功能的代码与项目有密切联系，这里就不多介绍了。如果相关开发人员需要在本地导出文件，可以考虑使用该API来实现。&lt;/p&gt;

&lt;h3 id=&quot;webkit-user-select&quot;&gt;-webkit-user-select&lt;/h3&gt;

&lt;p&gt;我们知道，如果我们把鼠标放到浏览器的文字上面，那么鼠标的标志会变成编辑状态。如果我们按下并且拖动，那么这部分的文字将会被选中进行高亮显示。如果我们再按下鼠标，会发现这部分文字是可以被拖动的（在html中表现为draggable属性为true）。&lt;/p&gt;

&lt;p&gt;在本项目中，这种行为是非常危险的。因为我们可以拖动整个table的column，来改变他们的顺序，因此每一个元素的draggable属性必须要个的由我们的代码来控制，一些浏览器默认的行为需要被禁止，包括我们上文提到的选中文字拖动操作。&lt;/p&gt;

&lt;p&gt;具体的禁止方式，就是在css中，把-webkit-user-select属性进行修改：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;body{
	-webkit-user-select: none;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;该属性设置成none之后就音质用户在页面上进行文字的选中。当然-webkit前缀规定了适用于chrome等浏览器，其他内核浏览器也有相应的修改方法，这里就不再阐述了。&lt;/p&gt;

&lt;h3 id=&quot;table&quot;&gt;修改table的宽度。&lt;/h3&gt;

&lt;p&gt;在本项目中，我们提供给用户一个功能，可以让他们随意来修改column的宽度。如果有很多column的话，用户可以将他们的宽度设置的小一点，这样就能看到更多了，提高用户体验。&lt;/p&gt;

&lt;p&gt;但是在具体的实现过程中，由于table本身有自适应的功能，以及jQuery本身的函数实现不同，会有很多的问题所在，这里就简单阐述一下设置的几点规则。&lt;/p&gt;

&lt;p&gt;一般而言，table的自适应是由于所有column宽度加起来不等于table的宽度而导致的。&lt;/p&gt;

&lt;p&gt;在自适应的过程中，table会优先改变从来没有设置过宽度的column，而table整体的宽度是保持不变的。&lt;/p&gt;

&lt;p&gt;如果所有的column的宽度都被制定过，那么我们在修改一个column的宽度时，其他所有column的宽度都会被改变。这种情况是非常糟糕的，一般都是不符合要求的。&lt;/p&gt;

&lt;p&gt;因此，如果我们要定制每一个column的宽度，我们有如下两种相对理想的解决方案。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;设置每一个column的宽度，并且计算总宽，赋值给table。确保table的宽度等于所有column的总宽。&lt;/li&gt;
  &lt;li&gt;保留一个column永远不设置宽度，做自适应项。（一般就是加一个空列）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;知道了规则，实现起来就方便很多了。然而，如果我们使用jQuery的$.fn.width()函数，我们会发现始终达不到我们的目标。原因是，$.fn.width()函数在box-sizing属性为border-box的元素中，不会计算其padding。而如果我们用bootstrap等常用的UI库做table时，通常都会有一个padding。因此在计算总宽时，除了对每一个column使用$.fn.width()函数外，也要加上padding值。&lt;/p&gt;

&lt;p&gt;还有一个解决的方案是不使用$.fn.width()函数，而是用$.fn.css(‘width’)，这样的话我们得到的宽度是算上padding的。但是注意该函数返回的结果是一个string，并且包含px等后缀，需要自行处理。&lt;/p&gt;

&lt;h3 id=&quot;ufeff&quot;&gt;神秘前缀\ufeff&lt;/h3&gt;

&lt;p&gt;这其实是uft-8的一个bom头。所谓bom头，就是用来标识该文件属于utf-8编码。由于我们项目中导出txt，csv文件这个功能里可能会包含有中文的字符，因此我们需要使用uft-8编码。&lt;/p&gt;

&lt;p&gt;这个bom头是微软自己规定的，他建议所有的 Unicode 文件应该以 ZERO WIDTH NOBREAK SPACE（U+FEFF）字符开头。这作为一个“特征符”来识别文件中使用的编码和字节顺序。但是目前，该bom头的兼容性并不好，只在windows操作系统相应的文件读取软件中使用，例如记事本等。如果我们用记事本打开一个文件，用uft-8格式保存之后，就会发现自动带上了这样一个bom头。&lt;/p&gt;

&lt;p&gt;本项目中，我们默认文件下载之后是需要用记事本来打开的，并且需要支持非英文字符，因此我们加上一个前缀\ufeff来告诉它，这是uft-8编码的字符串，这样才能得到正确的显示结果。&lt;/p&gt;

&lt;h3 id=&quot;roll-back&quot;&gt;roll back系统&lt;/h3&gt;

&lt;p&gt;为了防止用户误操作或者一些恶意操作，我们系统增加了一个回滚功能。具体的功能和git reset比较类似。&lt;/p&gt;

&lt;p&gt;我们记录用户所有的操作，包括对employee信息的修改以及对list的自定义。一条记录包括修改的时间，修改的用户，在什么上进行了修改，修改了什么，修改之前的数据和修改之后的数据等。用户随时都可以查看这些记录，如果点击了其中的一条记录，将会被roll back的所有记录都会被高亮显示，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/WAP/2.JPG&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里需要注意，如果是set default操作，那么在该记录之前的所有set default操作都会被回滚。如果是其他操作，那么该记录之前的作用与同一目标的所有操作会被回滚。这两条是我根据用户可能希望的结果自己制定的规则，之后可能会有所更改。&lt;/p&gt;

&lt;p&gt;实际的回滚操作还是比较简单的，我们已经有了所有要回滚的记录，根据第一条的记录的after以及最后一条记录的before来决定回滚所要执行的操作，然后将目标的值（assemble的column，employee的信息等）恢复为最后一条记录的before即可。&lt;/p&gt;

&lt;h3 id=&quot;textpixel&quot;&gt;测得一个text所占用的pixel&lt;/h3&gt;

&lt;p&gt;这部分其实是一个相对比较trick的实现。既然我们没有办法通过具体的某一个函数代码来计算出像素值，那么我们就将这部分文字放到dom中，看看实际占用多少就可以了。&lt;/p&gt;

&lt;p&gt;因此，我们新建一个&amp;lt;div&amp;gt;元素，设置如下的css:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#columnLengthCount{
	visibility: hidden;
	float: left;
	font-weight: bold;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;float属性可以让&amp;lt;div&amp;gt;的宽度根据text的长度来自适应。最后我们得到的该&amp;lt;div&amp;gt;的宽度就是一个text所占用的pixel了。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;双击和单击事件&lt;/h3&gt;

&lt;p&gt;在js的实践中，同时存在单击和双击事件。如果我们就正常的添加这两个事件的话，想要执行一次双击事件会额外执行两次单击事件。&lt;/p&gt;

&lt;p&gt;因此，在通常情况下，我们需要屏蔽掉这两次单击事件，仅仅执行双击。一般的解决方案是添加一个计时器，如果双击的时间间隔超过一个阈值，则看做是单击。如果时间间隔小于这个值（一般是0.3秒左右），则看做是双击。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$.fn.click(function(){
	clearTimeout(timer);
	timer = setTimeout(function(){
		...
	}, 300);
})

$.fn.dblclick(function(){
	clearTimeout(timer);
	...
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;点击空白处弹窗消失&lt;/h3&gt;

&lt;p&gt;在本项目中，使用到了一部分的弹窗：搜索框和回滚系统数据查看框。这部分弹窗使用的是bootstrap中的popover组件。该组件默认情况下是点击按钮出现，再点击按钮则消失。但是有时候，我们需要实现的效果是，点击按钮出现，然后点击任意其他空白位置消失。这样做可以提高用户的使用效率而不需要再去点击按钮。&lt;/p&gt;

&lt;p&gt;实现的思路很简单，在document绑定一个click时间，如果点击的位置不在弹窗内，则执行弹窗消失的操作：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(document).click(function(e){
	var _con = $(&#39;.popover&#39;);
	if (!_con.is(e.target) &amp;amp;&amp;amp; _con.has(e.target).length === 0){
		... //popover disappears
	}
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里_con就是我们显示的popover，如果点击事件的目标不是popover或者其子元素，则将其消失。&lt;/p&gt;

&lt;p&gt;That’s all.&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;明天七夕节，欢迎来约。&lt;/p&gt;

&lt;p&gt;干什么都可以，我奉陪到底，我买单到底。&lt;/p&gt;

</description>
        <pubDate>Sun, 27 Aug 2017 20:51:00 +0000</pubDate>
        <link>https://gougoumemeda.github.io/2017/08/27/Wap-STM-Web%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2017/08/27/Wap-STM-Web%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97/</guid>
        
        <category>Works Applications</category>
        
        <category>Web</category>
        
        <category>技术</category>
        
        
      </item>
    
      <item>
        <title>Wap入职第一周元气满满</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;毕业之后一直就无所事事，每天也就打打游戏偶尔出去聚会吃饭，晚上跑个步。所以整个七月过去的都非常的快，转眼间就要入职了。&lt;/p&gt;

&lt;p&gt;可能是因为日子轻松惯了，我也没有感觉这一刻有多么的“神圣”，就像一首歌里说的那样：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;其实爱对了人，情人节每天都过。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然而这实实在在的确实是我人生中新的篇章，因为16年的学生时代就此画上句号。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;正文&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;入职仪式&lt;/h3&gt;

&lt;p&gt;入职仪式在环球港的凯悦酒店进行。首先就是大BOSS们的讲话和欢迎仪式啦。有意思的是，我们有个HR大BOSS竟然连英文都不会说！真是难以想象霓虹国外语教学水平。他在演讲的时候，用的是日语，然后hr姐姐同声翻译（我想说的是这个HR姐姐长得超级超级超级可爱qwq）。我学过一点日语啦所以听懂还是问题不大的。&lt;/p&gt;

&lt;p&gt;然后是介绍一下各种职场的危险情况，包括性骚扰和职权欺凌。性骚扰讲了很久啊，之前看日剧就对日本的职场性骚扰有过耳闻，是不是这样的情况在日本真的很多？所以需要特别强调一下？&lt;/p&gt;

&lt;p&gt;然后就是大家进行一张合照啦！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/WAP/1.JPG&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之后就去我们的办公桌了。不得不承认，环球港B座真的是非常的气派，特别是那个电梯，可能是我孤陋寡闻了，有低中高三层也就算了，还不能自由选择楼层。你能前往的楼层由你的工卡决定。。。安全性满分。&lt;/p&gt;

&lt;p&gt;找到了自己的工位，拆电脑，装电脑，下软件，然后就开始干活啦！Fighting！！！&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;关于一天的生活&lt;/h3&gt;

&lt;p&gt;工作的生活其实并没有我想象中的那么累，只不过有些地方需要自己去慢慢适应。不如扯扯我的一天是怎么度过的哈哈哈哈哈哈。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;早上&lt;/h4&gt;

&lt;p&gt;7:20 起床，洗漱，穿好&lt;em&gt;西装&lt;/em&gt;。如果想要稍微帅气一点，就带个小领带。说道领带，我买了一根细的，带上去就发现自己根本不像一个上班的人233学生气十足。&lt;/p&gt;

&lt;p&gt;8:00 坐上陆安专线B线。由于我家的地(niao)理(bu)优(la)势(shi)，我上班只需要坐着一辆公交就可以，而且它会走高速公路，所以一般而言，9:15就能到公司。&lt;/p&gt;

&lt;p&gt;9:10 下车，去全家买早饭，心情好就买一杯咖啡喝喝。&lt;/p&gt;

&lt;p&gt;9:15 到公司，开始一天的工作。一般会先检查邮箱，git上进行代码的更新。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;下午&lt;/h4&gt;

&lt;p&gt;13:00 吃饭。不得不吐槽一下，在环球港吃饭！！！实在是！！！太贵了！！！每天只能去大食代吃，一般而言，30元RMB左右能够填饱肚子。虽然我知道日本更贵，但是让我一个刚从学校食堂10块吃饱的环境出来有点不太习惯呀。&lt;/p&gt;

&lt;p&gt;14:00 开始了下午的coding。我属于那种不能专注很久的，所以我有时候回去吧台（公司的）找找杂志看，或者喝一杯牛奶，放松一下继续工作。&lt;/p&gt;

&lt;p&gt;18:30 这是STM阶段理论上的下班时间，然而，然而！到了这个点，几乎是没有人走的，我的内心是崩溃的，大家要不要这么认真？？？？&lt;/p&gt;

&lt;p&gt;19:00 差不多陆陆续续的走了，包括我。&lt;/p&gt;

&lt;p&gt;19:40 坐上北安线，可能没有座位。听听歌，看看窗外两眼放空。这是我一天中最享受的时候。&lt;/p&gt;

&lt;p&gt;20:30 到家，吃饭，洗澡，睡觉。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;关于工作&lt;/h3&gt;

&lt;p&gt;由于我们是刚入职的员工，所以需要经历为期两个月到三个月的STM(starter mission)。&lt;/p&gt;

&lt;p&gt;STM由三个部分组成。&lt;/p&gt;

&lt;p&gt;第一个部分是基础知识，就是简单培训一下需要用到的知识。&lt;/p&gt;

&lt;p&gt;第二部分和第三部分都是相关的项目。项目包括Catalog和Implementation。具体的东西因为是公司机密所以我就不谈了哈，总之，我们的任务不仅仅是写代码，更多的是对产品的思考和定位，也就是，你是自己的产品经理和工程师。&lt;/p&gt;

&lt;p&gt;项目的难度其实并不大，主要是能不能有创造力的挖掘出产品的价值。目前来看我的实现还算比较顺利，也可能是因为我之前有相关开发网页的经历。我现在就希望能够快点结束STM，因为我不想穿西装上班啊qwq。&lt;/p&gt;

&lt;p&gt;在STM阶段，我们的网络访问也是有限制的，只能获取非常少的一部分英文资料，而且也没有wifi，手机上网全靠流量。值得一提的是，在网页白名单中，有requirejs和commonjs。这两个都是和js模块化有关的工具，后者我用的还是比较多的。但是，但是！commonjs仅仅定义了模块化的规则，并没有提供相关的编译方案（也就是没有webpack和browserify这样的工具）。所以实际上，如果要做模块化的话，还是要学习一下requirejs的使用。下一篇博客就来介绍一下这方面的东西吧！&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;上班怎么说，还是比较轻松愉快的吧。当然我明白在结束STM之后，真正的任务会接踵而至。&lt;/p&gt;

&lt;p&gt;目前来看，我现在最期盼的日子，一个是8月12日，TI7决赛，另一个是8月25日，发薪水。&lt;/p&gt;

&lt;p&gt;就是酱，喵！&lt;/p&gt;

</description>
        <pubDate>Sun, 06 Aug 2017 22:22:00 +0000</pubDate>
        <link>https://gougoumemeda.github.io/2017/08/06/Wap%E5%85%A5%E8%81%8C%E7%AC%AC%E4%B8%80%E5%91%A8%E5%85%83%E6%B0%94%E6%BB%A1%E6%BB%A1/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2017/08/06/Wap%E5%85%A5%E8%81%8C%E7%AC%AC%E4%B8%80%E5%91%A8%E5%85%83%E6%B0%94%E6%BB%A1%E6%BB%A1/</guid>
        
        <category>Works Applications</category>
        
        <category>生活</category>
        
        
      </item>
    
      <item>
        <title>Acemap学术地图功能和性能的完善</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;说一点题外话，我最终还是决定去东京。不是为了生活的有多好，只是想出去走走多看看世界。如果东京也能够容下我，那我应该也会定居在那里吧。&lt;/p&gt;

&lt;p&gt;其实是一个很艰难的决定，因为要顾忌到的东西有太多了。包括朋友，家人，还有东京那里的生活节奏，个人习惯等。我知道自己如果要考虑的话，还能纠结个几个月。但是纠结的日子是很痛苦的，想快点摆脱这种困扰，就狠下心来让自己做这个决定。嗯，他也是一个很草率的决定。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;正文&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;功能&lt;/h3&gt;

&lt;p&gt;上次在寒假那会儿已经把话题地图给完成了，而且将map和searchBar的公用部分代码都已经提取出来了。因此，剩下来功能上的部分就相对来说比较简单一些，只需要套用模板就行。&lt;/p&gt;

&lt;p&gt;首先是机构地图。机构地图，顾名思义，就是以一个机构为中心，该机构中的作者为节点显示的一张图。&lt;/p&gt;

&lt;p&gt;原先，我们地图中的所有线条都是直线的，这样并不美观。因此我们在这里将点与点之间的边用一根贝塞尔曲线来表示，具体绘制的函数如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function pathd(source,target,bezierCurveness){
	var x1 = Number(source.x);
	var y1 = Number(source.y);
	var x2 = Number(target.x);
	var y2 = Number(target.y);
	var length = Math.sqrt(Math.pow(x1-x2,2)+Math.pow(y1-y2,2));
	var factor = bezierCurveness*length;
	var v1_X = ((x2-x1+y2-y1)*factor+x1*length)/length;
	var v1_Y = ((y2-y1+x1-x2)*factor+y1*length)/length;
	var v2_X = ((x1-x2+y2-y1)*factor+x2*length)/length;
	var v2_Y = ((y1-y2+x1-x2)*factor+y2*length)/length;
	var result = &quot;M &quot;+String(x1.toFixed(6))+&quot;,&quot;+String(y1.toFixed(6))+&quot; C &quot;+String(v1_X.toFixed(6))+&quot;,&quot;+String(v1_Y.toFixed(6))+&quot; &quot;+String(v2_X.toFixed(6))+&quot;,&quot;+String(v2_Y.toFixed(6))+&quot; &quot;+String(x2.toFixed(6))+&quot;,&quot;+String(y2.toFixed(6));
	return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;该函数能够根据两个节点的坐标以及贝塞尔曲线的弧度来返回svg的路径。事实证明在美观程度上有了很大的提高，现在的UI如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Acemap/3.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因为急着上线，因此没有截取之前UI的图片，大家脑补一下即可。&lt;/p&gt;

&lt;p&gt;然后另外一张新地图是合作者地图，也就是以一个作者为中心，其他合作者为节点的地图。&lt;/p&gt;

&lt;p&gt;这个地图其实要改的东西还是非常之多的。除了将svg从前端生成，把左边的侧栏实现之外，还需要将原先作者页面的所有信息都搬到地图中。这对信息的筛选和整合是一个非常大的挑战。&lt;/p&gt;

&lt;p&gt;但是，这部分挑战仅仅是产品上的问题，只要我们知道要哪些东西，舍弃哪些东西，在技术上实现是没有难度的。唯一一个比较困难的问题是作者论文这一块。因为一个作者的论文数量有很多（最多的达8000+），因此我们需要添加一个分页的功能。那么究竟是前端分页还是后台分页呢？事实上，在目前绝大多数的上线产品中，分页都是使用后台分页的。如果我们数据量很大，大到需要分页的话，那么一次从后台传输这些数据的耗时是非常高的。我们将数据从数据库中取出来的时候就规定好一个start和一个offset，这样我们进行一次数据请求，返回的内容仅仅为一页所需要的内容。这么做虽然时间上有了节约，但是我们每一次分页都需要重新向后台请求数据。大部分情况下，后台分页比前段分页是有优势的。&lt;/p&gt;

&lt;p&gt;除此之外，论文部分还添加了一个根据年份筛选的功能。该功能直接将参数传入后台，在SQL语句中添加WHERE即可，没有难度。&lt;/p&gt;

&lt;p&gt;啊对了，这个分页器也是我自己写的，已经包装在一个文件中了。因为原先是想自己使用，因此也没有在接口和库文件规范上有下功夫，不过在这里我依然把代码公开一下，感兴趣的朋友可以自己用用看。&lt;a href=&quot;/js/pagination.js&quot;&gt;pagination.js&lt;/a&gt;，依赖于bootstrap和jquery。&lt;/p&gt;

&lt;p&gt;使用方法很简单，在html中插入如下语句：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;ul class=&quot;pagination pagination-sm&quot;&amp;gt;&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后，在js中初始化该pagination，初始化函数如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function initPagination(number, func)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;参数number是总共的页数，func是单击页码时执行的数据操作（一般也就是请求后台）。&lt;/p&gt;

&lt;p&gt;下面放上一张合作者地图新的UI图吧！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Acemap/4.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之前已经完成的话题地图也做了一点改进，将年份选择做成了滑杆的形式，两个滑块之间的就是选择的年份区间。滑杆就没有自己写了，用的是nst-slider这个第三方库，还是比较方便的。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;性能&lt;/h3&gt;

&lt;p&gt;前端性能上的提高就不提了，主要就是整理代码，减少重复的事件绑定和后台请求。这次主要是后台上的性能提高。&lt;/p&gt;

&lt;p&gt;首先是SQL上的query cache。之前我们把query cache一直都是打开的，然后有时候请求返回的速度就很慢。查log之后发现SQL一直在输出waiting for query cache lock。查阅了一下网上的资料，发现该cache会缓存之前使用过的SQL查询语句以及查询结果。这对于一些我们经常查询一样的内容并且表内容不频繁变化的情况会比较有用。但是在acemap中，我们每一次查询的内容几乎都是不同的，像paperid，authorid都是想变就变的。因此我们每一次查询的时候，就会刷新这个cache，刷新这个cache又会上锁。因此在并发数达到一定的情况下，就会有明显的卡顿现象了。&lt;/p&gt;

&lt;p&gt;然后是redis缓存。我们在话题地图的前50名作者功能中，使用了redis作为数据缓存。因为这个表的大小很大，如果每一次都从SQL中取出的话，会很占用时间。redis将数据缓存在内存之中，而且并不是使用表结构，而是我们代码中更为常见的字典结构，一个key对应一个value，因此使用上也非常的方便。在后台我们判断一下在redis中是否有数据缓存即可：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if ($redis -&amp;gt; hExists($topicID, &#39;famousAuthor&#39;)){
	$authors = json_decode($redis -&amp;gt; hGet($topicID, &#39;famousAuthor&#39;), TRUE);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;大概就是这样。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;目标&lt;/h3&gt;

&lt;p&gt;目前我们所有的地图上的功能都已经实现了，下一阶段会着重在搜索这一块。搜索组已经在后台开始使用了solr引擎，只不过目前还没有移植到前端。之后在了解了相应的使用方法之后，我会及时的在前端跟进的。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;看我这么认真的做毕设写博客的份上，求天赐我一个女朋友。&lt;/p&gt;

</description>
        <pubDate>Sat, 15 Apr 2017 12:45:00 +0000</pubDate>
        <link>https://gougoumemeda.github.io/2017/04/15/Acemap%E5%AD%A6%E6%9C%AF%E5%9C%B0%E5%9B%BE%E5%8A%9F%E8%83%BD%E4%B8%8E%E6%80%A7%E8%83%BD%E7%9A%84%E5%AE%8C%E5%96%84/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2017/04/15/Acemap%E5%AD%A6%E6%9C%AF%E5%9C%B0%E5%9B%BE%E5%8A%9F%E8%83%BD%E4%B8%8E%E6%80%A7%E8%83%BD%E7%9A%84%E5%AE%8C%E5%96%84/</guid>
        
        <category>Acemap</category>
        
        <category>Javascript</category>
        
        <category>技术</category>
        
        
      </item>
    
      <item>
        <title>Acemap学术地图前端代码的重构</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;今天是个美好的日子，只可惜不属于我而已。虽然没有出去约女孩子，但一个人在宿舍学完一课日语，健身房里跑跑步，打打游戏晚上再写下这篇博文，也是非常惬意的。&lt;/p&gt;

&lt;p&gt;这是一篇关于毕业设计的博文。之前在选择毕设的时候也是一波三折，因为老师名额不够，所以导致我需要去补录志愿。所幸最后老师帮我争取到了一个名额，能够让我成功获得毕业的机会。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;正文&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;毕设主要内容&lt;/h3&gt;

&lt;p&gt;我的毕设是纯工程的，没有什么理论。也就是说，不需要看大量论文，大部分的工作还是写代码。要做的是一个学术地图，名字叫做&lt;a href=&quot;http://acemap.sjtu.edu.cn&quot;&gt;Acemap&lt;/a&gt;。在我加入项目组之前，已经完成了一部分工作了，但是代码质量参差不齐。最后的项目目标是，能够将所有的地图都统一起来，有统一的格式。具体的UI可以参考谷歌地图。我负责的部分是前端，总体来说，我要做的内容就是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;设计合适的前端代码架构&lt;/li&gt;
  &lt;li&gt;重构前端代码，理清结构&lt;/li&gt;
  &lt;li&gt;设计UI&lt;/li&gt;
  &lt;li&gt;功能实现&lt;/li&gt;
  &lt;li&gt;完成文档和注释内容&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;代码架构&lt;/h3&gt;

&lt;p&gt;我们后台使用的是CodeIgniter框架。说实话，这个框架已经老的掉牙了，可能是之前几年的学长挑选的，现在要更换也已经几乎是不可能的了，因为代码数量已经非常庞大了。学习了一下CodeIgniter，个人感觉还是挺麻烦的。而且，在controller如何控制view的那段示例代码中，有类似如下的片段：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$this -&amp;gt; load -&amp;gt; view(&#39;header&#39;);
$this -&amp;gt; load -&amp;gt; view(&#39;content&#39;);
$this -&amp;gt; load -&amp;gt; view(&#39;footer&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最终我们显示的代码，是这三个文件中代码的顺序拼接。这样做其实我自己很不喜欢，原因有如下几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;每一个文件的代码都没有完整的html格式&lt;/li&gt;
  &lt;li&gt;最终显示页面的html源代码不够直观，需要看多个文件&lt;/li&gt;
  &lt;li&gt;模块化不够明显。虽然header也可以作为某一个单独的模块列出来，但是其必定会带有一些html标签，在使用的时候不够方便。而且他只支持顺序的模块，没有办法实现一个模块中嵌套另一个模块。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原本我最理想的而前端架构是用ReactJS或者VueJS，因为最终页面的风格是要统一的，公共的部分包括&lt;em&gt;搜索栏&lt;/em&gt;， &lt;em&gt;svg地图&lt;/em&gt;，因此只要将这两者作为模块单独放在文件中，由外界向他们传数据就可以很好的进行复用。这么做的话，最理想的是在基础页面加载完毕后，再通过RESTFUL API向后台请求获得具体的数据。但是，目前我们后台是将页面需要的数据直接传递给页面的，这样做的话，我们的页面必须以php结尾，才能够使用那些传递过来的数据，但即使这么做了，JS代码里是不能够嵌入PHP代码的，因此我们没有办法让ReactJS/VueJS模块得到后台controller直接传过来的数据，这样的代码架构就不能实现。如果要做的话，后台的代码就要重构，前端的代码也要重构，工作量之大并不是目前能顾得上的。&lt;/p&gt;

&lt;p&gt;因此，前端这一块，目前并没有使用任何的框架。只是用了jQuery以及相关的一些库。因为jQuery是没有模块化的，因此我们也没有办法使用npm来引入相关的jQuery第三方插件。项目整体还是比较原始的，目前来看的话，也只能这样子了。&lt;/p&gt;

&lt;p&gt;最终我对这个项目的前端代码框架的构思是，将&lt;em&gt;搜索栏&lt;/em&gt;，&lt;em&gt;svg地图&lt;/em&gt;这两个可以复用的部分的js代码单独拿出来建一个文件，然后一个页面只使用一个.php文件，页面中需要用到的特定的js代码以内联的方式写在.php文件中。这样可以在保证代码清晰的前提下，能够最大程度的复用一些组件。&lt;/p&gt;

&lt;h3 id=&quot;svg&quot;&gt;SVG地图生成&lt;/h3&gt;

&lt;p&gt;在我加入项目组之前，SVG地图是已经在后台生成完毕，作为一个单独的文件，在controller中进行拼接的。这样做有好处也有坏处，好处是加载的速度比较快，坏处就是可拓展性不强，如果有新的地图，我们就需要在后台重新生成一边，相对而言也比较占用空间。&lt;/p&gt;

&lt;p&gt;目前我们已经抛弃了这样的方式，取而代之的是，用js代码来生成相应的svg地图。我们在后台存储了相应的地图所需要的元素，并用如下的代码读取出来：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$sql = &quot;SELECT PaperID, Radius, X, Y, View1, View2, Year, JournalID, ConferenceID, LabelSize, LabelX, LabelY, Label FROM papermap_4_node WHERE FieldID = ?&quot;;
$nodes = $this-&amp;gt;db_svg-&amp;gt;query($sql, array($topicID))-&amp;gt;result_array();
//get edges
$sql = &quot;SELECT SourceID, TargetID, Width, View1, View2 FROM papermap_4_edge WHERE FieldID = ?;&quot;;
$edges = $this-&amp;gt;db_svg-&amp;gt;query($sql, array($topicID))-&amp;gt;result_array();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;得到相应的点和边的数据之后，将其传到前端，绘制成svg即可。&lt;/p&gt;

&lt;h3 id=&quot;deferred&quot;&gt;Deferred对象&lt;/h3&gt;

&lt;p&gt;defered对象是jQuery的回调函数解决方案。这次我们在项目中使用到了这个技术，有两个目的，一是为了让一些点击事件的绑定能够生效，二是将一些地图其他的数据的读取放在地图显示之后。这些数据本身是依赖于地图的，缺少地图的话他们将无法显示完全。&lt;/p&gt;

&lt;p&gt;在使用上Deferred对象非常简单，如果要新建一个对象，执行下述代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var dtd = $.Deferred(); // 新建一个Deferred对象
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;jQuery规定，deferred对象有三种执行状态—-未完成，已完成和已失败。如果执行状态是”已完成”（resolved）,deferred对象立刻调用done()方法指定的回调函数；如果执行状态是”已失败”，调用fail()方法指定的回调函数；如果执行状态是”未完成”，则继续等待，或者调用progress()方法指定的回调函数。&lt;/p&gt;

&lt;p&gt;一般来说，我们指定“已完成”的状态居多。设定这个状态的代码为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dtd.resolve()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ui&quot;&gt;UI界面&lt;/h3&gt;

&lt;p&gt;UI方面的话，我引入了bootstrap-standstone。相对来说还是比较美观，又带有些许严谨的风格，和“学术地图”这样的主题很相称。除此之外，我将领域的一些介绍内容也搬到了地图中，包括领域的父话题，子话题和该领域内发表论文数前50的作者。这样原本是两个页面，现在就合成一个页面了，风格也得到了统一。具体的话，还是直接来看对比图吧。&lt;/p&gt;

&lt;p&gt;之前的UI：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Acemap/1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在的UI：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Acemap/2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;虽然我也不是专业的设计师，但我觉得还是美观了不少的。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;做了其实也不少，剩下的开学之后再说吧！&lt;/p&gt;

</description>
        <pubDate>Tue, 14 Feb 2017 21:30:00 +0000</pubDate>
        <link>https://gougoumemeda.github.io/2017/02/14/Acemap%E5%AD%A6%E6%9C%AF%E5%9C%B0%E5%9B%BE%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E7%9A%84%E9%87%8D%E6%9E%84/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2017/02/14/Acemap%E5%AD%A6%E6%9C%AF%E5%9C%B0%E5%9B%BE%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E7%9A%84%E9%87%8D%E6%9E%84/</guid>
        
        <category>Acemap</category>
        
        <category>Javascript</category>
        
        <category>技术</category>
        
        
      </item>
    
      <item>
        <title>使用Processing制作交大饮食的可视化报告</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;序言&lt;/h2&gt;

&lt;p&gt;突然发现自己已经很久没有更新过博客了。主要原因是自己太闲了，大四上学期没有找什么实习，也没有课，在宿舍就是dota和日语的日子，所以就没有什么可以记录的啦。不过12月的时候，有个学弟让我帮他用Processing做一个可视化报告，我一口就答应了下来，因为有钱拿。&lt;/p&gt;

&lt;p&gt;其实我之前没有用过Processing，所以也是半学半用的在写代码。令人欣慰的是，Processing出奇的简单，学弟的这个大作业，我用了两天就做完了，惬意惬意。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;正文&lt;/h2&gt;

&lt;h3 id=&quot;processing&quot;&gt;Processing介绍&lt;/h3&gt;

&lt;p&gt;我就不搬运什么网上的内容了，自己简单介绍一下Processing吧。&lt;/p&gt;

&lt;p&gt;Processing是一种可视化框架，也可以理解成一个Java框架。其所用的语言就是Java，有自己完善的生命周期以及基础接口函数。用起来非常简单直接暴力，所有文件中的变量和函数都是通用的，不需要什么MVC，MVVM这样的架构，一个页面就是一个文件，清晰明了。&lt;/p&gt;

&lt;p&gt;在我的理解中，Processing并不是写软件的框架，而仅仅是将数据用图像化的方式呈现出来。当然，PPT之类的软件可以做到这一点，但是从交互性和可控性来说，肯定没有Processing出色。&lt;/p&gt;

&lt;h3 id=&quot;processing-1&quot;&gt;Processing的生命周期&lt;/h3&gt;

&lt;p&gt;其实Processing的生命周期，好听点叫生命周期，难听点就是一个启动函数和一个刷新函数。怎么样，是不是很简单。&lt;/p&gt;

&lt;p&gt;页面加载时，调用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void setup(){}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;页面刷新时，调用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void draw(){}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里有一点要注意，draw()函数在每一帧都会调用，而且不会清除上一帧的图像。即使是静止的页面，也可能是无数层相同图像的叠加。因此在draw()函数的第一行，我们通常会手动清除页面上的内容。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;实现时的一些编码细节&lt;/h3&gt;

&lt;p&gt;这次我们做的是2014-2015秋季学期交大闵行校区食堂的报告（1%取样），包括消费人群性别统计，学历统计。也有所有食堂在不同月份的总共的消费额。同时，调查了人均的挑费次数和消费额度，以及在交大二餐中最受欢迎的几种菜系。&lt;/p&gt;

&lt;p&gt;在使用Processing绘图的时候，可以设置一些模式，这些设置是可以被之后的设置所覆盖的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;imageMode(CORNER);
image(back, 20, 20);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样我们就设置了image的绘制模式。如果在之后再次调用了imageMode但是传入了不同的参数，那么原来的CORNER模式会被覆盖掉。&lt;/p&gt;

&lt;p&gt;此外，由于所有的函数和变量是在不同文件中共享的，因此我在第一次加载的时候就想所有的数据都处理完毕，这样在之后的使用过程会流畅很多。&lt;/p&gt;

&lt;p&gt;所有使用到的变量如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//all the data we need
float[] genderPortions = new float[2];
float[] educationPortions = new float[3];
int[][] volumnInMonths = new int[5][7];
int[][][] volumnInTime = new int[5][7][17];
int[][] volumnInPerson = new int[198][3];
String[][] topName = new String[3][3];
int[][] topValue = new int[3][3];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;成果&lt;/h3&gt;

&lt;p&gt;下面放出几张最终效果图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Processing/1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Processing/2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Processing/3.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;虽然很久没有写代码了，但是每次接触到代码还是会很投入。接下来的目标是做好毕设，写好小程序外包，然后参加wwdc！&lt;/p&gt;

</description>
        <pubDate>Fri, 13 Jan 2017 21:30:00 +0000</pubDate>
        <link>https://gougoumemeda.github.io/2017/01/13/%E4%BD%BF%E7%94%A8Processing%E5%88%B6%E4%BD%9C%E4%BA%A4%E5%A4%A7%E9%A5%AE%E9%A3%9F%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8A%A5%E5%91%8A/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2017/01/13/%E4%BD%BF%E7%94%A8Processing%E5%88%B6%E4%BD%9C%E4%BA%A4%E5%A4%A7%E9%A5%AE%E9%A3%9F%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8A%A5%E5%91%8A/</guid>
        
        <category>Processing</category>
        
        <category>技术</category>
        
        <category>可视化</category>
        
        
      </item>
    
      <item>
        <title>Unity中使用Animation提高Animator的性能</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;序言&lt;/h2&gt;
&lt;p&gt;这次我要跟大家分享的是使用Animation来实现Animator的功能。其实效果没有之前Curve那么酷炫，但是工作量比之前的会大上好多。&lt;/p&gt;

&lt;p&gt;为什么要使用Animation来实现Animator呢？很大一部分原因是在于性能。Animator的性能是被人们所诟病的，在模拟之前我也不知道使用Animation能提高多少的性能，只是觉得可能是一种方式，所以就做了这件事。下面我们就进入正题，聊聊具体的方式。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;正文&lt;/h2&gt;
&lt;p&gt;平台：Unity 4.6&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;概念与运作方式&lt;/h3&gt;
&lt;p&gt;首先我们来明确一下Animator的概念以及运作方式。Animator本质上就是一个组件（Component），可以挂载到任意一个GameObject上，其核心在于AnimatorController。我们平常所看到的AnimatorController的图形化结构是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Animation/1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;本质上而言，AnimatorController就是多个状态机的组合，其中的状态就是动画，而状态的转换就是动画的过渡。我们要实现的呢，就是状态机。只不过里面还有很多细节和其他功能比如Layer，BlendTree等。&lt;/p&gt;

&lt;p&gt;我们从宏观到微观的角度来看controller，序号越小表示所包含的东西越多，概念越大：
1. controller本身，其中主要是paramaters和各个layer的基本信息。
2. layer，在animator中，我们对每一个layer都需要进行state和transition的更新。
3. stateMachine，通常来说，一个layer就是一个stateMachine，但是stateMachine也可以包含其他的sub-stateMachine。
4. state和transition，这些都是包含在stateMachine中的，也是controller中最核心的部分。
5. animationClip，包含在一个state中，真正动画播放的东西。&lt;/p&gt;

&lt;p&gt;下面我们一个一个具体的介绍上述部件的功能。&lt;/p&gt;

&lt;h4 id=&quot;parameters&quot;&gt;Parameters&lt;/h4&gt;
&lt;p&gt;“参数”是用来控制Transition的发生的。当参数满足一个Transition触发的所有条件时，这个Transition就会执行。从图形化的角度来看，参数就是以下图来表示的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Animation/2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们在代码中，可以通过SetInt，SetFloat等方法来修改参数的值。具体使用方法可以参考Unity手册。&lt;/p&gt;

&lt;h4 id=&quot;layer&quot;&gt;Layer&lt;/h4&gt;
&lt;p&gt;Layer在AnimatorController中，表示如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Animation/3.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;他的作用主要是用来控制不同层动画的混合，比如你有一个投掷的动画和一个走路的动画，你想上半身来投掷，下半身 走路的话，就可以通过Layer来实现。在Layer中我们看到有weight，Mask和Blending可以供开发者选择。weight用来控制混合 的权重，0表示不混合（动画不播放），其他数值会以一个融合的比重来播放动画，这里weight的值并不是绝对的，还会根据Blending的选择来更 改，如果Blending为Override，那么最终播放的时候当前层的动画会覆盖更浅层的动画，如果Blending为Additive，那么当前层 的weight会与更浅层的weight相加，再归一化。Mask是用来控制当前Layer的动画使用在身体的哪个部分的。我们可以在Unity中创建一 个Mask Avatar，通过设置它来达到控制身体部位的效果。&lt;/p&gt;

&lt;h4 id=&quot;statemachine&quot;&gt;StateMachine&lt;/h4&gt;

&lt;p&gt;一个StateMachine就是一个状态机，也就是我们最直观的看到的那一块区域：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Animation/4.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通常来说，一个layer就是一个stateMachine，但是stateMachine也可以包含其他的sub-stateMachine。&lt;/p&gt;

&lt;h4 id=&quot;state&quot;&gt;State&lt;/h4&gt;
&lt;p&gt;State在AnimatorController中表示为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Animation/5.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;实际上，一个State就包含了一个动画或者多个动画的融合（BlendTree）。在每一个State中，我们都可以找到AnimationClip，而它就是真正被播放的东西。我们状态机就是在不同的State之间进行转换，也就是在不同的动画中进行过渡与播放。值得一提的是，我们有一个很特殊的State叫AnyState，它可以表示任何一个State，换句话说，从它发出的Transition可以看作是从其他State中发出的。&lt;/p&gt;

&lt;h4 id=&quot;transition&quot;&gt;Transition&lt;/h4&gt;
&lt;p&gt;Transition就是在AnimatorController中的箭头，表示为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Animation/6.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当我们选中一个Transition时，可以在右边看到触发时的条件，这些条件必须全部都满足时才会被触发。Transition是一个动画到另一个动画的过渡，这个过渡是有时间的。当过渡完成之后，动画的状态才会切换。有一类Transition的条件仅仅是Exit Time，表示当动画播放了一段时间后自动会触发这个Transition。&lt;/p&gt;

&lt;p&gt;具体我们模拟Animator的时候，可以这么做（Update函数）：
1. 遍历每一个layer（可用多线程）
2. 在一个layer中，遍历当前state发出的所有transition，看看是否有所有conditions都满足的transition
3. 如果没有，结束
4. 如果有，则开始这个transition
5. transition是有时间的，所以当transition结束后，将当前的state设置成transition的dstState&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;实现&lt;/h3&gt;

&lt;h4 id=&quot;section-4&quot;&gt;解析&lt;/h4&gt;
&lt;p&gt;在实现这个Animator的时候，因为我们使用的是Unity 4.6，并没有与AnimatorController相关的API，所以我们需要自己解析controller文件。如果要看到controller文 件的原内容，我们需要设置一下Project Setting - Edtior，将其中的Aseet Serialization设置为Force Text，然后将controller文件使用任意编辑器打开（sublime），就能看到controller中所有的数据结构啦。我们在实际解析这些数据结构的时候，可以在代码中直接创建相应的类和成员变量，以State为例，在controller中他是这么表示的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gd&quot;&gt;--- !u!1102 &amp;amp;110273390
&lt;/span&gt;State:
  m_ObjectHideFlags: 3
  m_PrefabParentObject: {fileID: 0}
  m_PrefabInternal: {fileID: 0}
  m_Name: Attack01
  m_Speed: 1
  m_CycleOffset: 0
  m_Motions:
  - {fileID: 7400000, guid: 904f2f79e9c87534f903a673c7adb132, type: 3}
  m_ParentStateMachine: {fileID: 110728656}
  m_Position: {x: -94, y: 183, z: 0}
  m_IKOnFeet: 0
  m_Mirror: 0
  m_Tag: 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们创建的类如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class State
{
    public int m_id;
    public string m_Name;
    public float m_Speed;
    public float m_CycleOffset;
    public bool m_IKOnFeet;
    public bool m_Mirror;

    public List&amp;lt;AnimationClip&amp;gt; m_Motions; // one motion per motion set  
    public BlendTree m_MotionsWithBlendTree;

    public StateMachine m_ParentStateMachine;
    public Vector3 m_Position;
    public string m_Tag;

    public State(int id)
    {
        m_id = id;
        m_Motions = new List&amp;lt;AnimationClip&amp;gt;();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中，id为controller中第一行最后的那一串数字，其他的成员变量名字和controller中的大致都是一样的。因为一个 State可能是一个BlendTree，所以我们添加了一个m_MotionsWithBlendTree来表示这个State对应的 BlendTree（如果有的话）。然后，m_Motions存储的就是要被Animation播放的动画片段。&lt;/p&gt;

&lt;p&gt;这里有一点需要注意，我们需要将原来的动画片段复制一遍，把他的animationType设置成Lagecy，才能被Animation所支持。具体复制和设置的代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;string animationPath = &quot;Assets/Character/Animations/&quot; + guid + state.m_id + &quot;.FBX&quot;;
//AssetDatabase.CopyAsset(AssetDatabase.GUIDToAssetPath(guid), animationPath);
var animationObject = AssetDatabase.LoadAssetAtPath(animationPath, typeof(AnimationClip)) as AnimationClip;
if (!animationObject.name.Contains(state.m_id.ToString()))
      animationObject.name = animationObject.name + state.m_id;
AnimationUtility.SetAnimationType(animationObject, ModelImporterAnimationType.Legacy);
state.m_Motions.Add(animationObject);
state.m_MotionsWithBlendTree = null;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在上述代码中我们发现，我们对animationClip的名字进行的修改，原因在于，可能在不同Layer的两个State中有相同的AnimationClip，他们完全可以同时进行播放。在controller中，他们也是以不同的guid来表示的，说明他们是两个对象。而在Animation中，我们的Clip是以名字进行标识的，所以这里要给他们换一个名字。&lt;/p&gt;

&lt;p&gt;最后一点需要注意的是，还记不记得我们之前说在Layer中可以添加Mask。我们打开.mask文件后，发现会有一些m_Path，我们把m_Weight为1的所有path当成字符串保存起来，之后在模拟的时候会使用到。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;模拟&lt;/h4&gt;

&lt;p&gt;解析完controller文件后，就可以模拟Animator的行为了。&lt;/p&gt;

&lt;p&gt;首先我们要将所有的动画添加到Animation中去，在添加的时候，可以设置AnimationState.layer来实现不同layer的混合效果， 然后我们要实现mask的效果，可以使用函数AddMixingTransform，他接受两个参数，一个是transform，这里我们就可以使用解析 得到的m_Path了，使用transform.find(m_Path)就能得到我们真正需要的子transform（也就是mask），另一个参数表 示是否递归，这里根据.mask的文件结构来看，我们选择false即可。&lt;/p&gt;

&lt;p&gt;另外需要注意的是，Animation没有直观的数据结构可以表示BlendTree，我们要根据parameter的值以及各个动画片段的threshold来计算出他们的权重。这里以1D为例，计算权重的函数如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void UpdateWeightsAndSpeedsInBlendTree1D(AnimatorCompiler.BlendTree blendTree)
{
      float para = floatConditions[blendTree.m_BlendParameter.m_Name];
      AnimatorCompiler.BlendTree.Child left = null;
      AnimatorCompiler.BlendTree.Child right = null;
      for (int i = 0; i &amp;lt; blendTree.m_Childs.Count; ++i)
      {
            AnimatorCompiler.BlendTree.Child child = blendTree.m_Childs[i];
            if (para &amp;gt;= child.m_Threshold &amp;amp;&amp;amp; child.m_Threshold &amp;lt; blendTree.m_MaxThreshold)
            {
                  if (left == null || child.m_Threshold &amp;gt; left.m_Threshold)
                  {
                        left = child;
                  }
            }
            else if (para &amp;lt;= child.m_Threshold)
            {
                  if (right == null || child.m_Threshold &amp;lt; right.m_Threshold)
                  {
                        right = child;
                  }
            }
            weightInBlendTrees[blendTree][child] = 0.0f;
            speedInBlendTrees[blendTree][child] = 0.0f;
      }
      if (left != null &amp;amp;&amp;amp; right != null)
      {
            float lp = 1 - (para - left.m_Threshold) / (right.m_Threshold - left.m_Threshold);
            float rp = 1 - lp;
            weightInBlendTrees[blendTree][left] = lp;
            weightInBlendTrees[blendTree][right] = rp;
            float leftTime = left.m_Motion.length / left.m_TimeScale;
            float rightTime = right.m_Motion.length / right.m_TimeScale;
            speedInBlendTrees[blendTree][left] = left.m_Motion.length / (leftTime * lp + rightTime * rp);
            speedInBlendTrees[blendTree][right] = right.m_Motion.length / (leftTime * lp + rightTime * rp);
      }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;1D还是比较简单的，找到与parameter的值相邻的两个threshold，然后对这两个threshold所表示的AnimationClip的weight进行插值即可。2D的weight计算可以参考&lt;a href=&quot;http://runevision.com/thesis/rune_skovbo_johansen_thesis.pdf&quot;&gt;这篇文章&lt;/a&gt;的6.3节。&lt;/p&gt;

&lt;p&gt;大部分的更新Transition的逻辑都在Update函数中完成，那么我们要怎么来模拟这个Transition的过程呢？一种比较显然的方法是使用CrossFade，我们来看看CrossFade的函数原型。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void CrossFade(string animation, float fadeLength = 0.3F, PlayMode mode = PlayMode.StopSameLayer);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;animation为我们的目标动画，fadeLength就是过渡的时间，也就是transition的时间。我们解析得到的m_TransitionDuration是一个百分比，需要乘上原动画的时间。 CrossFade的原理是，将animation的weight设置成1，enable设置成true，然后在fadeLength的时间内将原动画的 weight降为0，再把他的enable设置成false。这样就有一个问题，在blendTree中的动画不一定weight就为1，而且在高层的 Layer中的weight也不一定为1，所以我们不能直接使用CrossFade，而是自己将它实现一遍再进行一些修改，大致的代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;foreach (var item in parser.animation.m_State)
{
      AnimatorCompiler.State state = item.Value;
      if (state.m_id == 0)
            continue;
      if (state.m_ParentStateMachine.m_Index == layer.m_Index)
      {
            if (state.m_id != transition.m_DstState.m_id)
            {
                  if (state.m_MotionsWithBlendTree == null)
                  {
                        gameObject.animation.Blend(state.m_Motions[0].name, 0, currentTransitionInLayers[layer].m_TransitionDuration * animationLength);
                  }
                  else
                  {
                        for (int j = 0; j &amp;lt; state.m_MotionsWithBlendTree.m_Childs.Count; ++j)
                        {
                              AnimatorCompiler.BlendTree.Child child = state.m_MotionsWithBlendTree.m_Childs[j];
                              gameObject.animation.Blend(child.m_Motion.name, 0, currentTransitionInLayers[layer].m_TransitionDuration * animationLength);
                        }
                  }
            }
      }
}
if (currentTransitionInLayers[layer].m_DstState.m_MotionsWithBlendTree == null)
{
      gameObject.animation.Stop(transition.m_DstState.m_Motions[0].name);
      gameObject.animation[transition.m_DstState.m_Motions[0].name].enabled = true;
      gameObject.animation[transition.m_DstState.m_Motions[0].name].weight = ((layer.m_Index == 0) ? 1 : layer.m_DefaultWeight);
}
else
{
      for (int i = 0; i &amp;lt; currentTransitionInLayers[layer].m_DstState.m_MotionsWithBlendTree.m_Childs.Count; ++i)
      {
            AnimatorCompiler.BlendTree.Child child = currentTransitionInLayers[layer].m_DstState.m_MotionsWithBlendTree.m_Childs[i];
            gameObject.animation.Stop(child.m_Motion.name);
            gameObject.animation[child.m_Motion.name].enabled = true;
            gameObject.animation[child.m_Motion.name].weight = weightInBlendTrees[currentTransitionInLayers[layer].m_DstState.m_MotionsWithBlendTree][child];
      }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;剩下的部分只要细心耐心的按照animator模拟的步骤慢慢实现即可，没有什么太多的坑。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;改进&lt;/h3&gt;

&lt;p&gt;好了，如果你按照上述的步骤写完了，然后想打包一下跃跃欲试，你会发现你失败了。原因是我们在复制AnimationClip的时候，使用了AssetDatabase，他是属于UnityEditor的一个类，而UnityEditor无法打包。因此我们需要把解析的过程放在Editor中完成，然后将解析的结果都串行化，保存起来。&lt;/p&gt;

&lt;p&gt;你可以小心翼翼的在每个类上面加上[System.Serializable]，但是这么做依然是不行的，因为我们在类中表示其他的对象时，使用都是其他对象的指针，所以很容易就产生循环引用，在Editor中无法被串行化，例如，state类中有一个parentStateMachine指向一个StateMachine，而在一个StateMachine中又保存了他所有state的指针。&lt;/p&gt;

&lt;p&gt;因此，我们需要修改整个解析得到的类的数据结构，将指针替换为对象的id（int类型）。以State为例，我们可以与之前的代码进行对比：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[System.Serializable]
public class State
{
      public int m_id;
      public string m_Name;
      public float m_Speed;
      public float m_CycleOffset;
      public bool m_IKOnFeet;
      public bool m_Mirror;

      public List&amp;lt;AnimationClip&amp;gt; m_Motions; // one motion per motion set    
      public int m_MotionsWithBlendTree;

      public int m_ParentStateMachine;
      public Vector3 m_Position;
      public string m_Tag;

      public State(int id)
      {
            m_id = id;
            m_Motions = new List&amp;lt;AnimationClip&amp;gt;();
            m_MotionsWithBlendTree = -1;
      }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由于我们把解析的过程放在了Editor中完成，因此运行的速度也会更快一些。&lt;/p&gt;

&lt;p&gt;那么我们还有什么办法可以提高性能吗？&lt;/p&gt;

&lt;p&gt;答案肯定是有的，这里就采用了“生成代码”的办法。我们真正运行时的逻辑代码，是在Editor中生成的，而不是提前写好的。可能听起来有点绕，我把我的工程的文件结构给大家看一下：&lt;/p&gt;

&lt;p&gt;Editor：
- AnimatorCodeGenerator.cs：生成模拟Animator的代码
- AnimatorParser：解析controller文件&lt;/p&gt;

&lt;p&gt;Scripts：
- AnimationByAnimator：模拟Animator
- AnimationController：控制gameObject
- AnimatorCompiler：controller文件的数据结构
- AnimatorData：用来存储解析controller文件后的结果
- CodeUtil：生成代码时使用的工具&lt;/p&gt;

&lt;p&gt;这样应该清晰了很多，那么这么做有什么好处呢？&lt;/p&gt;

&lt;p&gt;如果我们平常来写的话，必然会使用到大量的字典，比如parentStateMachineInStates，我们在解析的数据结构 中，parentStateMachine保存的是StateMachine的Id，只有id是没有办法直接在模拟代码中使用的，我们要把这个id换转成 真正的StateMachine的对象，因此他在模拟代码中的类型应该是Dictionary&amp;lt;State, StateMachine&amp;gt;。由于使用字典会产生大量的cache miss，因此性能并不出色。而生成代码最大的优势是能循环展开并且避免使用字典，其原理就在于能够“通过不同的字符串来运用变量”。&lt;/p&gt;

&lt;p&gt;我们来看一个例子，在codeGenerator中，有这样的一段代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (int i = 0; i &amp;lt; animation.m_Transition.Count; ++i)
{
      AnimatorCompiler.Transition transition = animation.m_Transition[i];
      code.Variable(&quot;&quot;, &quot;AnimatorCompiler.State&quot;, code.Normalize(&quot;srcStateInTransitions_&quot; + transition.m_id));
      code.Variable(&quot;&quot;, &quot;AnimatorCompiler.State&quot;, code.Normalize(&quot;dstStateInTransitions_&quot; + transition.m_id));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Variable函数就是创建响应的变量名。运行这段代码，生成的代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AnimatorCompiler.State srcStateInTransitions_110100396;
AnimatorCompiler.State dstStateInTransitions_110100396;
AnimatorCompiler.State srcStateInTransitions_110128666;
AnimatorCompiler.State dstStateInTransitions_110128666;
AnimatorCompiler.State srcStateInTransitions_110144588;
AnimatorCompiler.State dstStateInTransitions_110144588;
AnimatorCompiler.State srcStateInTransitions_110150974;
AnimatorCompiler.State dstStateInTransitions_110150974;
AnimatorCompiler.State srcStateInTransitions_110152432;
AnimatorCompiler.State dstStateInTransitions_110152432;
AnimatorCompiler.State srcStateInTransitions_110183908;
AnimatorCompiler.State dstStateInTransitions_110183908;
AnimatorCompiler.State srcStateInTransitions_110193682;
AnimatorCompiler.State dstStateInTransitions_110193682;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到，原先的Dictionary被展开成了不同的变量，而且我们把循环函数放在了Editor中完成，因此运行时的效率会更高一些。而这些就是生成代码所给我们带来的好处。&lt;/p&gt;

&lt;p&gt;不过，生成代码非常非常容易出错，大家在写的时候一定要仔细！&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;性能&lt;/h2&gt;

&lt;p&gt;测试时，我们重点关注Update函数消耗的时间，无论是Animator还是我们写的这个系统，Update函数始终都是核心，也是最最耗时的一部分。&lt;/p&gt;

&lt;p&gt;这次我们依然在安卓机上测试，创建300个物体，先挂上Animator，得到的图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Animation/7.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，所有Update函数的时间和为40.74+19.41=60.15ms。&lt;/p&gt;

&lt;p&gt;现在我们来看看用我们的系统：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Animation/8.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;总的Update函数时间为17.82+10.95+5.85=34.62ms。&lt;/p&gt;

&lt;p&gt;我们可以看到，在平均情况下，Animation实现的系统已经比Animator快了接近一倍，而在实现中可以优化的地方依旧有很多，代码也不是最美观，如果你有什么好的建议，欢迎联系我！&lt;/p&gt;

</description>
        <pubDate>Fri, 09 Sep 2016 13:00:00 +0000</pubDate>
        <link>https://gougoumemeda.github.io/2016/09/09/Unity%E4%B8%AD%E4%BD%BF%E7%94%A8Animation%E6%8F%90%E9%AB%98Animator%E7%9A%84%E6%80%A7%E8%83%BD/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2016/09/09/Unity%E4%B8%AD%E4%BD%BF%E7%94%A8Animation%E6%8F%90%E9%AB%98Animator%E7%9A%84%E6%80%A7%E8%83%BD/</guid>
        
        <category>Unity</category>
        
        <category>技术</category>
        
        <category>腾讯</category>
        
        
      </item>
    
      <item>
        <title>使用Shader实现任意曲线的颜色渐变和纹理移动</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;扯蛋时间&lt;/h2&gt;

&lt;p&gt;上次做了一个LineRender，手动Batch，对于我一个新手而言，这无疑是黑科技。&lt;/p&gt;

&lt;p&gt;但是我想错了。&lt;/p&gt;

&lt;p&gt;这次导师给我布置的任务才是真正的黑科技，我们需要在Material Inspector中绘制任意的曲线，来控制材质的颜色渐变和纹理的平移。我们都知道，shader中支持的类型都是非常基本的，float啊，int啊，稍微复杂一点的比如float4这样的，但是并没有一个类型能表示一条曲线。所以这次对我而言看上去是一个不小的挑战，但是既然来了腾讯，就要有面对挑战的决心和觉悟。当然，我也是完成了这项任务之后才来写这篇Blog的。我的导师非常善良，没有让我直接去画不规则曲线，而是先做了一个Sin函数变化曲线，然后通过设置参数的方式来调整一个他的图像，并且在Material Inspector中直观的显示出来。&lt;/p&gt;

&lt;p&gt;感兴趣的话，可以继续看下去。如果想直接看任意曲线部分，&lt;a href=&quot;#curve&quot;&gt;请猛戳我!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;sin&quot;&gt;Sin函数图像&lt;/h2&gt;

&lt;p&gt;我们先来看看结果是怎么样的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Curve/inspector.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;介绍一下各个参数吧：
- Time：动画的周期
- Speed：Sin函数在y轴上的拉伸
- OffsetY：Sin函数在y轴上的平移
- OffsetX：Sin函数在x轴上的平移
- 颜色选择框：Sin函数在两个极值时的颜色
- OffsetMax：纹理平移的最大位置
- OffsetMin：纹理平移的最小位置
- OffsetSpeedX：纹理在X轴平移的速度
- OffsetSpeedY：纹理在Y轴平移的速度&lt;/p&gt;

&lt;p&gt;我们可以看到，虽然说可以显示Sin函数的图像，但是其局限性还是相当大的。首先他本质上就是一个Sin函数，然后我们只是通过修改参数，看到Sin函数的变化，而不能在图像上直接增减Keyframe。但这个做法为我们之后任意曲线提供了思路。&lt;/p&gt;

&lt;p&gt;我们先定位到Shader文件中。在Shader中，我们实现了具体的算法，也就是说，给定上述提到的各个参数，怎么把颜色或者纹理的变化画出来。我们在绘制两种颜色之间的渐变时，使用的是插值的技术，也就是将两部分颜色按照一定的比例混合起来，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;o.color = v.color * (_TintColor * t + (1 - t) * _TintColorMin);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;两个变量的含义从名字就可以看出来。现在我们要思考如何把t算出来，这个t事实上就是Sin函数的y值。有过高中数学知识的朋友都知道，Sin函数的一般形式为&lt;code class=&quot;highlighter-rouge&quot;&gt;y=Asin(w(x + t)) + b&lt;/code&gt;。其中周期为2pi / w。我们将上述的参数都带入，得到：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;float t = saturate(sin((time + _SpeedColorOffsetX) / _Interval * 6.283185307) * _SpeedColorCutoff + _SpeedColorOffset);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样，我们就把颜色渐变的部分完成了，最外面的saturate函数是保证t的值始终在0-1之间，因为插值技术只支持t的范围为0-1。&lt;/p&gt;

&lt;p&gt;现在我们来看看纹理的平移要如何达到。其实纹理的平移更加简单，速度乘以时间就是平移的距离，但是要注意我们有一个最大最小值，要保证平移的距离在这个范围之内：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;currentUV += clamp(time * float2(_SpeedX, _SpeedY), _MinX, _MaxX);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;有一点需要提到，因为我们的动画是可以循环的，所以time的值为真实的时间对周期取模：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;float time = fmod(_Time.y, _Interval);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面就是Shader的主要思路，现在我们回到Editor，看看如何把这个Sin函数曲线画出来。其实非常简单，因为我们已经知道怎么算Sin函数了，所以我们只要在Editor中再算一边即可。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (float x = 0; x &amp;lt; interval; x = x + interval / 100)
{
	float value = Mathf.Sin((x + speedColorOffsetX) / interval * 6.283185307f) * speedColorCutoff + speedColorOffset;
	value = Mathf.Clamp(value, 0, 1);
	colorCurve.AddKey(new Keyframe(x, value));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们在Sin函数上取100个点进行采样，计算出这一百个点的值，然后把他封装成一个Keyframe，添加到AnimationCurve的Key中。注意一点，Keyframe是需要添加入切线和出切线的，但是我们并没有添加，所以在点少的情况下看上去并不像一个Sin函数，因此我们选择100个采样点，让两个点更加靠近，看上去就更像是一根平滑的曲线。至此，我们的Sin函数图像的绘制的就全部结束了，剩下的一下EditorGUILayout的调用查阅API手册即可。&lt;/p&gt;

&lt;p id=&quot;curve&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;任意曲线绘制&lt;/h2&gt;
&lt;p&gt;简单来说，我们接下去要做的事，就是能够直接在图像上增减Keyframe，不用手动输入参数，然后能够在Shader中计算出对应的值，通过插值的方法达到颜色渐变和纹理平移的效果。我们这里只说颜色渐变的方法，因为纹理平移和颜色渐变的思路是一模一样的，复制两次代码即可。&lt;/p&gt;

&lt;p&gt;老规矩，先看一张成品图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Curve/curveinspector.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里我们的参数就少了很多，唯一有的是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Loop：是否循环播放&lt;/li&gt;
  &lt;li&gt;Duration：周期&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们这次先来讲讲大致的思路是怎么样的。我遇到的第一个疑问是，对于任意一根曲线，怎么计算出在某一个x上的y的值？unity自带有一个方法叫做AnimationCurve.Evaluate(time)，我们传进去一个time，也就是x，就能帮我们计算出y的值。但是这个方法只能在C#中使用，如果要像Sin函数那样在Shader中计算一遍，那该怎么做呢？有同学可能会说，在C#中计算好再传进去，那样我们每一帧都要传递一个值，开销会很大，所以建议还是在Shader中做计算。事实上，我们只需要知道Evaluate函数具体的算法，在Shader中实现一遍就好了，于是我谷歌到了下面的东西：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;float evaluate(float time, float4 keyframe1, float4 keyframe0)
{
	float t = (time  - keyframe0.x) / (keyframe1.x - keyframe0.x);
	float dt = keyframe1.x - keyframe0.x;
	float m0 = keyframe0.w * dt;
	float m1 = keyframe1.z * dt;
	float t2 = t * t;
	float t3 = t2 * t;
	float a = 2 * t3 - 3 * t2 + 1;
	float b = t3 - 2 * t2 + t;
	float c = t3 - t2;
	float d = -2 * t3 + 3 * t2;
	float value = a * keyframe0.y + b * m0 + c * m1 + d * keyframe1.y;
	return saturate(value);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Nice！这就是Unity的Evaluate函数的具体实现。我们只要把这个函数搬到Shader的CGPROGRAM代码块中就好啦！&lt;/p&gt;

&lt;p&gt;但是新的问题又来了，这个函数需要两个keyframe参数（相邻的两个keyframe），这两个keyframe肯定是要从material editor中传进去的，如果我们只传这两个参数，那和用C#计算完把结果穿进去有什么区别呢，还是需要每一帧（可能多个帧）传递数据一次，毕竟时间在x轴上跑，相邻的两个keyframe会变。我们最理想的情况是，不会因为时间的缘故而传递数据。因此，我们需要在曲线绘制完毕后，就将所有的keyframe传进去，然后在Shader中计算此时相邻的keyframe是哪两个，这样开销会小很多。所以现在的关键点是，如何传递所有的keyframe到Shader中，以及如何计算出当前时间相邻的两个Keyframe？&lt;/p&gt;

&lt;p&gt;我们先来回答第一个问题。回到Editor，我们绘制曲线在OnInpectorGUI()这个函数中，有一点需要注意，我们必须将绘制完的曲线赋给原来的变量，否则曲线是不会变化的！&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;colorCurve = EditorGUILayout.CurveField(colorCurve, Color.green, new Rect(0, 0, 1.0f, 1.0f), GUILayout.Height(150));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后，&lt;code class=&quot;highlighter-rouge&quot;&gt;colorCurve&lt;/code&gt;就是我们最终得到的动画曲线。我们只要取colorCurve.keys就能够得到他所有的Keyframe了。这里有一点需要注意，我们在Editor中设置的曲线范围都是0-1之间的，而且keyFrame必须至少有2个，否则曲线就失去了意义，这点在代码中需要判断一下。另外，我们有一个Duration变量来控制周期，所以我们需要保证最后一个keyframe的x坐标必须为1，表示1秒，在最终绘制曲线的时候，会将时间放慢Duration倍，达到周期为Duration的效果，例如如果想在3.5秒完成一次动画，就把Duration设置成3.5即可。总而言之，Curve的绘制只是告诉我们变化的曲线，具体变化需要多久，由Duration来控制，这样做会使得美术更加容易理解，代码的实现也会更加简单。这部分代码在Shader中实现，Editor中只需要保证x的坐标为1即可：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (number &amp;gt;= 2)
{
	keys[number - 1].time = 1.0f;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后我们遍历每一个KeyFrame，传递到Shader中就好。&lt;/p&gt;

&lt;p&gt;现在回答第二个问题，如何知道离时间最近的两个Keyframe。最简单的方法就是在Shader中遍历所有的Keyframe，判断时间的关系。这么做可以，但是非常耗时，每一帧都需要遍历，而且每一个顶点都要遍历一遍。所以我没有采用这样的方法，而是做了一个Hash Table，在Editor中计算完之后传递给Shader，把变量命名为TimeTable，其中他的下标是时间（取整），值就是在下标表示的时间时下一个Keyframe的序号（Index）。这里需要插一句话，Keyframe在Shader中需要float4来存储，我们规定一根曲线上不能超过10个keyframe，所以三根曲线就有30个float4。而CG最多支持128个float4，因此我们大约只能再用90个float4。所以TimeTable的类型为float4，其中x，y，z分别为三根曲线所用。这里我们只介绍颜色，所以用x分量就可以。&lt;/p&gt;

&lt;p&gt;可能会有同学好奇，时间取整作为下标，那3.2秒和3.6秒时对应的Keyframe是同一个咯？如果在3.5秒和3.7秒有一个Keyframe的话，计算出的结果就是错误的！我们现在换个思路，TimeTable的大小为90，也就是说动画周期最长可以是90，但实际上我们根本不需要这么久的时间，动画周期在Editor里就已经确定了，而Editor中Keyframe的time最大就是1.0，所以我们可以将时间“拉长”90倍，也就是说，在每一个Keyframe的time上乘以90作为一个界限。这么说有点抽象，我们举个例子：假设在0.5秒和0.6秒有两个keyframe，如果直接取整，那么0.6秒这个keyframe会直接被无视掉。现在我们乘以90，得到45和54，也就是说，当真正的时间乘上90小于45的话，会取前面的keyframe，在45-54之间的话，就会取后面的keyframe，这样就把两个keyframe“区分”开来了，更直观一点，就是把他们的距离拉长了90倍，时间可以放进去了！&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (; currentTime &amp;lt;= (int)(keys[i + 1].time * 90); ++currentTime)
{
	timeTable[currentTime][type] = i + 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;代码就是这样，type就是x，y，z分量，最终我们在Shader中使用时，只要把真实的时间乘以90作为下标，就能得到正确的下一个keyframe了！&lt;/p&gt;

&lt;p&gt;现在我们两个问题都解决了！去Shader中看看具体剩下的部分吧！&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;float beginTime = _Time.y - v.time.x;
beginTime = max(0, beginTime);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这一部分是控制一个GameObject什么时候开始动画，如果没有这一块，那所有的GameObject都是同步动画的，因为他们共享的是同一个Material（为了Batch）。我们需要区分他们动画开始的时间，就需要在Mesh中把开始时间传递进去，如果没到那个时间，那当前动画运行的时间就始终是0，如果到了，那就是真实的动画运行时间了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;float time = ((1 - _Loop) * clamp(beginTime, 0, _Duration) + _Loop * fmod(beginTime, _Duration)) / _Duration;
float4 currentVector = _TimeTable[floor(time * 90)];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;time控制是否需要循环播放动画，而且范围始终在0-1之间，与Editor相匹配。由于我们除以了一个Duration，所以时间被放慢了Duration倍！达到了Duration控制周期的效果！后面一行的time*90就是之前所说过的部分。&lt;/p&gt;

&lt;p&gt;剩下的部分，就是找到keyframe，传到evaluate函数计算出结果，与颜色做插值，这些在Sin函数部分都已经讲过了，就不再重复了。&lt;/p&gt;

&lt;p&gt;到此为止，我们的代码就彻底完成啦！&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;性能测试&lt;/h2&gt;

&lt;p&gt;又到了喜闻乐见的性能测试环节了，先来看看用Animation做颜色渐变和纹理平移的效果。创建500个GameObject，挂载Animation，运行在安卓手机上：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Curve/animation.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关注Camera.Render，时间大约为38ms。现在来看看我们自己写的Shader执行颜色渐变和纹理平移的效率：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Curve/shader.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;发现Camera.Render的时间只要15ms左右。虽然没有Line Renderer那么惊艳，但是还是节约了一半多的时间，原因还是在Batch上面，因为我们是在Material和Shader中做这些事情，而同一个Material是自动会被Batch的，所以节约了一部分Draw Call的开销。此外，用Animation做还特别麻烦，需要每一种渐变效果都做一个Animation。而用Material，只要拖拖曲线，画画keyframe就好，美术会更加喜欢的！&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;当然，如果你有什么问题的话，请在评论中告诉我~&lt;/p&gt;
</description>
        <pubDate>Thu, 04 Aug 2016 16:00:00 +0000</pubDate>
        <link>https://gougoumemeda.github.io/2016/08/04/%E4%BD%BF%E7%94%A8Shader%E5%AE%9E%E7%8E%B0%E4%BB%BB%E6%84%8F%E6%9B%B2%E7%BA%BF%E7%9A%84%E9%A2%9C%E8%89%B2%E6%B8%90%E5%8F%98%E5%92%8C%E7%BA%B9%E7%90%86%E7%A7%BB%E5%8A%A8/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2016/08/04/%E4%BD%BF%E7%94%A8Shader%E5%AE%9E%E7%8E%B0%E4%BB%BB%E6%84%8F%E6%9B%B2%E7%BA%BF%E7%9A%84%E9%A2%9C%E8%89%B2%E6%B8%90%E5%8F%98%E5%92%8C%E7%BA%B9%E7%90%86%E7%A7%BB%E5%8A%A8/</guid>
        
        <category>Unity</category>
        
        <category>技术</category>
        
        <category>腾讯</category>
        
        
      </item>
    
      <item>
        <title>Unity中LineRender的实现与优化</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;闲聊&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.unity3d.com/Manual/class-LineRenderer.html&quot;&gt;Line Renderer&lt;/a&gt;，简单来说就是在一个三维的空间中生成一条线。既然是线，那么我们无论从那个角度上去看，都能看到他的正面对吧，毕竟线是在二位平面中的事物。那么在三维平面中，这个line是怎么做到的呢？其实很简单，我们镜头在旋转的过程中，保持line的正面始终面对着镜头就可以了。可能有人会说为什么不用一个圆柱体来搞定。原因很简单，圆柱体太重量级了，想象我们是在玩一个FPS游戏，我们不可能对每一个弹道都用一个圆柱体来表示吧，使用line renderer不仅仅可以实现一样的效果，而且开销更加小。&lt;/p&gt;

&lt;p&gt;Line Renderer和Billboard还有一些不一样，billboard对着你的角度也是固定死的，也就是说，无论镜头怎么变，billboard在你眼前的模样始终是一样的，这被广泛应用在NPC头上的字中。而line，只要给我们看到正面就可以了。&lt;/p&gt;

&lt;p&gt;给一张line的图片好了~&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/LineRenderer/line-render.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;我们究竟要干什么呢&lt;/h2&gt;

&lt;p&gt;用过Unity的朋友都知道，Unity自带了一种Line Renderer，在Effect Component中可以找到。这个line可以调整的参数是，起点的位置，终点的位置，起点的宽度以及终点的宽度，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/LineRenderer/para.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我想测试一下这个renderer的性能，于是我放了500个对象上去，发现他竟然用了500个draw call来一个一个画。嗯，是时候给Line Renderer瘦瘦身了！接下来我们就来自己实现这样一个line renderer，并且让他的性能比原生的更好。CPU的能耗很大一部分都在draw call上面，把这部分draw call给合并成一个，那么能耗会大大下降，而合并的方法，就是batch。Unity提供了静态Batch和动态Batch，当然也可以用代码手动创建Batch。除此之外，我们不能为一个GameObject创建Mesh Renderer，因为我们需要手动去batch，所以batch后的mesh也需要我们手动去绘制。&lt;/p&gt;

&lt;p&gt;所以，整体的步骤如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;写一个脚本，脚本创建Mesh，设置vertice和index。&lt;/li&gt;
  &lt;li&gt;在移动镜头的时候调整物体的位置，达到line的效果。&lt;/li&gt;
  &lt;li&gt;创建一个MeshCombine的脚本，其中包含一个BatchList，类型是List&lt;BatchInfo&gt;，能够把line都添加进去。Line会根据他们的Material和Layer自动归类到相应的BatchInfo，而一个BatchInfo只需要一次DrawCall。&lt;/BatchInfo&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接下来我们就一步一步的来实现这个功能。&lt;/p&gt;

&lt;h4 id=&quot;mesh&quot;&gt;脚本创建Mesh&lt;/h4&gt;
&lt;p&gt;这个其实比较简单，可以参考&lt;a href=&quot;http://www.cnblogs.com/kyokuhuang/p/4191169.html&quot;&gt;这篇文章&lt;/a&gt;。需要注意的是，文章中创建的是一个立方体，而我们只需要创建一个正方形。&lt;/p&gt;

&lt;p&gt;这里还有一点是可以优化的，刚才我们说，line只会把正面给镜头看，也就是说在游戏运行时，玩家是看不到物体的背面的，所以我们也不需要为背面划分三角形创建Index。综上所述，我们只要创建一个单一面的正方形。一共有4个定点，2个三角形，6个索引。&lt;/p&gt;

&lt;h4 id=&quot;line&quot;&gt;Line效果实现&lt;/h4&gt;
&lt;p&gt;这里需要一点点数学的知识，不知道大家还记不记得向量叉乘相关的知识，不记得的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%90%91%E9%87%8F%E7%A7%AF&quot;&gt;猛戳我&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;假设我们现在知道了line的起点，终点的位置，但是他并不是面向镜头的，我们现在要让他转向镜头，可以用下面的方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;计算出起点和终点的中点，并且和镜头位置相连接，得到向量1。&lt;/li&gt;
  &lt;li&gt;连接起点和终点，得到向量2。&lt;/li&gt;
  &lt;li&gt;向量1与向量2进行叉乘，我们得到一个垂直于他们的向量3。向量3需要标准化。&lt;/li&gt;
  &lt;li&gt;向量2作为轴，将line进行旋转，使得平面与向量3平行。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面四个步骤完成之后，我们就会发现line已经转向镜头了。这样我们无论怎么移动镜头，都是不会看到line的背面的。&lt;/p&gt;

&lt;p&gt;第四步旋转其实也非常简单，根据起点和终点的位置，起点和终点的宽度以及向量3就可以计算出line的四个顶点坐标，然后绘制即可。具体的代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;float halfTailWidth = TailWidth / 2;
float halfHeadWidth = HeadWidth / 2;
Vector3 viewer = Camera.main.transform.position - HeadPosition;
Vector3 lineDir = HeadPosition - TailPosition;
Vector3 direction = Vector3.Cross(viewer, lineDir).normalized;

m_Vertices[0] = TailPosition - direction * halfTailWidth;
m_Vertices[1] = TailPosition + direction * halfTailWidth;
m_Vertices[2] = HeadPosition - direction * halfHeadWidth;
m_Vertices[3] = HeadPosition + direction * halfHeadWidth;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;meshcombine&quot;&gt;创建一个MeshCombine&lt;/h4&gt;
&lt;p&gt;现在到了我们真正节约开销的部分了。之前提到过，在MeshCombine中需要有一个List&lt;BatchInfo&gt;，这个List中每一个元素代表需要batch到一起的对象。怎么样的对象需要batch到一起，很简单，就是他们的material和layer都是相同的。现在我们来看看BatchInfo的成员变量。&lt;/BatchInfo&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class BatchInfo
{
    public int Layer;
    public Material Material;
    public List&amp;lt;CombineInstance&amp;gt; CombineInstance = new List&amp;lt;CombineInstance&amp;gt;();
    public CombineInstance[] CombineInstanceArray = null;
    public Mesh Mesh;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中，Layer和Material都是相同的，ConbimeInstance是最终我们要combine在一起的物体对象集合，而Mesh就是combine出的结果，最终要绘制的东西，占用一个Draw Call的东西。&lt;/p&gt;

&lt;p&gt;需要注意的是，我们在Line Renderer的脚本中的Update函数中计算四个顶点的位置，而计算完位置之后才能进行绘制，所以在这个脚本中我们绘制的代码需要放在LateUpdate函数中，具体如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void LateUpdate()
{
    for (int i = 0; i &amp;lt; BatchList.Count; ++i)
    {
        var batchInfo = BatchList[i];
        if (batchInfo.CombineInstanceArray == null)
        {
            if (batchInfo.CombineInstance.Count &amp;lt;= 0)
            {
                if (batchInfo.Mesh != null)
                {
                    Destroy(batchInfo.Mesh);
                }
                BatchList.RemoveAt(i);
                --i;
                continue;
            }
            batchInfo.CombineInstanceArray = batchInfo.CombineInstance.ToArray();
        }
        if (batchInfo.Mesh == null)
        {
            batchInfo.Mesh = new Mesh();
        }
        batchInfo.Mesh.CombineMeshes(batchInfo.CombineInstanceArray, true, false);
        Graphics.DrawMesh(batchInfo.Mesh, Matrix4x4.identity, batchInfo.Material, batchInfo.Layer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;CombineMeshes函数就是把所有的Mesh合并成一个Mesh，DrawMesh就是讲Mesh绘制到屏幕上，占用一个Draw Call。&lt;/p&gt;

&lt;p&gt;到此为止，我们的优化和实现已经全部完成了，下面来看看性能对比。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;性能对比&lt;/h2&gt;

&lt;p&gt;我们先在安卓手机上创建2000个对象，并且挂载系统自带的Line Renderer，得到的性能图像如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/LineRenderer/system.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们只需要关注Camera.Render的耗时，因为这一项代表的就是draw call的耗时，也是我们可以优化的一项。我们发现数值大约为93ms。&lt;/p&gt;

&lt;p&gt;现在我们挂载自己的Line Renderer，也是2000个对象：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/LineRenderer/mine.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们发现Camera.Render的耗时只有0.49ms！！足足快了大约190倍！可见batch的强大之处。那么这是不是意味着我们的Line Renderer就完胜系统的呢？其实不是的，在GPU的消耗上，我们略微的输给了系统的，但是因为CPU才是主要影响性能的因素，所以我们会把大部分的注意力都放在CPU上面，换句话说，我们的Line Renderer是成功的。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;可能是长期在写业务逻辑的缘故，对于这样的优化以及改进我一开始是无从下手的。但当我们真正“入门”之后，会发现优化是一件非常有趣非常有成就感的事情，我也能够感受到自己是一名“程序员”而不是“码农”，我想，不停的超越也是写代码的乐趣之一吧。&lt;/p&gt;

</description>
        <pubDate>Wed, 27 Jul 2016 12:00:00 +0000</pubDate>
        <link>https://gougoumemeda.github.io/2016/07/27/Unity%E4%B8%ADLineRender%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BC%98%E5%8C%96/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2016/07/27/Unity%E4%B8%ADLineRender%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BC%98%E5%8C%96/</guid>
        
        <category>Unity</category>
        
        <category>技术</category>
        
        <category>腾讯</category>
        
        
      </item>
    
      <item>
        <title>鹅厂是个好地方</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“来腾讯实习快两周了，感触颇深。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;放假之前&lt;/h2&gt;

&lt;p&gt;其实给我Offer的也只有两个公司。一个是携程，还有一个就是腾讯了。虽然腾讯把我安排到了深圳，但毕竟是大厂，能进去总觉得有一种自豪感。所以两者之中，我还是毫不犹豫的选择了腾讯。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-1&quot;&gt;放假中&lt;/h2&gt;

&lt;p&gt;在去腾讯之前，去了一次欧洲。游玩了德国和荷兰，为时九天。荷兰的夜生活相当丰富，荷兰的法律相当开明，可能这也是uber遵循荷兰法律的原因之一吧。40欧就能看到真人AV秀，你值得拥有。&lt;/p&gt;

&lt;p&gt;应该算是第二次来深圳，上次来的时候还是大一暑假，也是南山，也是腾讯。两年之后故地重游，也就有了一丝亲切感。到住的地方是凌晨两点，因为深圳的暴雨，飞机延误了四个小时。住的地方很简陋，一张桌，一个衣柜，没了。第二天赶紧购置了一批生活用品，买了一张床上桌子，否则真的没有办法写代码。&lt;/p&gt;

&lt;p&gt;13号，周三，正式入职的一天。早上就一直在忙碌着各种手续，在腾大和科兴之间来回穿梭。在科兴吃了一顿午饭，竟然要30元，这让月薪不足3000的我怎么活下去？见到导师大约是下午两点半，高高瘦瘦，非常干净，说话声音很轻，一眼就可以看出来是一个二次元，有着二次元男性透露出的那种宅属性。公司配置的电脑相当给力，i7，960，16G，这个配置完全可以特效全开的玩守望先锋。想到这里，我不禁心里暗喜。&lt;/p&gt;

&lt;p&gt;你以为我就这样可以玩游戏了？公司的网络是不能访问外网的，需要配置各种代理。于是我的守望先锋计划整整延后了两周，终于在公司KM平台上找到了运行的方法。每天中午的午休时间就变成了我的战斗时间。&lt;/p&gt;

&lt;p&gt;导师人相当不错，培养思路非常清晰，第一周我熟悉一下Unity这个平台，然后开发一款游戏出来。我选择的是我大一做过的游戏是男人就坚持二十秒。其实游戏思路很简单，只是我要去慢慢熟悉这个平台。完成之后还没结束，我需要将其优化，通用化，增加他的鲁棒性和可拓展性。&lt;/p&gt;

&lt;p&gt;比如说，生成岩石的过程中，RockController来控制每一个独立的岩石，Pool控制所有岩石的初始化，销毁与复用，RockGenerator来设置每一波岩石的各个参数，比如速度，数量等，而SpawnManager就是真正让一波岩石移动的类。这样的结构用在这个项目上看上去有一点大材小用，但是当项目规模大了，这样的架构就非常有必要。&lt;/p&gt;

&lt;p&gt;腾讯的食堂味道也非常不错，每顿还会有免费的水果。除了价格比较贵，其他真的挑不出什么毛病。如果你加班到晚上八点之后，还会获得一张夜宵券，虽然叫夜宵券，但他是可以用来刷晚饭的，也就是说，免费请你吃一顿第二天的晚餐。&lt;/p&gt;

&lt;p&gt;之前在知乎上看到，如何评价2016年的腾讯。在回答中，大家基本上都是在表扬腾讯。BAT三家中，似乎腾讯已经成为了最出色的一家。来到腾讯之后，深觉腾讯的确是这样一家公司。有时候会抱怨他的收费贵，但是他是一家做实事的公司。你以为只有你们吐槽腾讯吗！每次在KM平台上都会看到腾讯自己人对自己产品的各种抱怨，当然也会有相关的负责人员及时反馈与修复，所以腾讯才能越来越壮大。&lt;/p&gt;

&lt;p&gt;我所在的部门是IEG，互动娱乐事业群，也就是做游戏，娱乐相关的。说来有点惭愧，我现在没有在玩任何一款腾讯系的游戏。有时候会想，腾讯在世界上游戏行业收入第一，那么为什么没有独立研发出现象级的游戏产品呢？我们耳熟能详的英雄联盟，CF都是其他公司开发，腾讯代理或者收购的。近来腾讯也收购了前段时间风靡全球的部落冲突的开发商supercell，但是在收购之后，又出来了Pokemon Go。大家总说腾讯喜欢抄，没错，可能就是因为这样的抄，让腾讯没有办法在游戏行业成为像暴雪那样的信仰公司。腾讯总是会去收购，代理一些成熟的，已经风靡的游戏，而不敢去接触一些未知的领域和挑战（比如AR技术Pokemon Go），可能这就是原因吧。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;放假之后&lt;/h2&gt;

&lt;p&gt;虽然两周时间已经很喜欢腾讯了，但是我还是想回上海，想和大伙儿们一起去网吧开黑，一起吃火锅，一起洗澡。在深圳觉得自己就是一个废人，除了上班就是看剧，除了看剧就是写博文，除了写博文就是打游戏，活生生的变成了葛优。&lt;/p&gt;

</description>
        <pubDate>Mon, 25 Jul 2016 12:00:00 +0000</pubDate>
        <link>https://gougoumemeda.github.io/2016/07/25/%E9%B9%85%E5%8E%82%E6%98%AF%E4%B8%AA%E5%A5%BD%E5%9C%B0%E6%96%B9/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2016/07/25/%E9%B9%85%E5%8E%82%E6%98%AF%E4%B8%AA%E5%A5%BD%E5%9C%B0%E6%96%B9/</guid>
        
        <category>生活</category>
        
        <category>腾讯</category>
        
        <category>工作</category>
        
        
      </item>
    
  </channel>
</rss>
